The Go Programming Language
----
(March 28, 2008)

This document is an informal specification/proposal for a new systems programming
language.


Guiding principles
----

Go is a new systems programming language intended as an alternative to C++ at
Google. Its main purpose is to provide a productive and efficient programming
environment for compiled programs such as servers and distributed systems.

The design is motivated by the following guidelines:

- very fast compilation (1MLOC/s stretch goal); instantaneous incremental compilation
- procedural
- strongly typed
- concise syntax avoiding repetition
- few, orthogonal, and general concepts
- support for threading and interprocess communication
- garbage collection
- container library written in Go
- reasonably efficient (C ballpark)

The language should be strong enough that the compiler and run time can be
written in itself.


Modularity, identifiers and scopes
----

A Go program consists of one or more `packages' compiled separately, though
not independently.  A single package may make
individual identifiers visible to other files by marking them as
exported; there is no ``header file''.

A package collects types, constants, functions, and so on into a named
entity that may be exported to enable its constituents be used in
another compilation unit.

Because there are no header files, all identifiers in a package are either
declared explicitly within the package or arise from an import statement.

Scoping is essentially the same as in C.


Program structure
----

A compilation unit (usually a single source file)
consists of a package specifier followed by import
declarations followed by other declarations.  There are no statements
at the top level of a file.

A program consists of a number of packages.  By convention, one
package, by default called main, is the starting point for execution.
It contains a function, also called main, that is the first function invoked
by the run time system.

If any package within the program
contains a function init(), that function will be executed
before main.main() is called.  The details of initialization are
still under development.


Typing, polymorphism, and object-orientation
----

Go programs are strongly typed.  Certain values can also be
polymorphic.  The language provides mechanisms to make use of such
polymorphic values type-safe.

Interface types, building on structures with methods, provide
the mechanisms to support object-oriented programming.
Different interface types are independent of each
other and no explicit hierarchy is required (such as single or
multiple inheritance explicitly specified through respective type
declarations).  Interface types only define a set of methods that a
corresponding implementation must provide.  Thus interface and
implementation are strictly separated.

An interface is implemented by associating methods with
structures.  If a structure implements all methods of an interface, it
implements that interface and thus can be used where that interface is
required.  Unless used through a variable of interface type, methods
can always be statically bound (they are not ``virtual''), and incur no
runtime overhead compared to an ordinary function.

Go has no explicit notion of classes, sub-classes, or inheritance.
These concepts are trivially modeled in Go through the use of
functions, structures, associated methods, and interfaces.

Go has no explicit notion of type parameters or templates.  Instead,
containers (such as stacks, lists, etc.) are implemented through the
use of abstract operations on interface types or polymorphic values.


Pointers and garbage collection
----

Variables may be allocated automatically (when entering the scope of
the variable) or explicitly on the heap.  Pointers are used to refer
to heap-allocated variables.  Pointers may also be used to point to
any other variable; such a pointer is obtained by "taking the
address" of that variable.  Variables are automatically reclaimed when
they are no longer accessible.  There is no pointer arithmetic in Go.


Functions
----

Functions contain declarations and statements.  They may be
recursive.  Functions may be anonymous and appear as
literals in expressions.


Multithreading and channels
----

Go supports multithreaded programming directly. A function may
be invoked as a parallel thread of execution.  Communication and
synchronization is provided through channels and their associated
language support.


Values and references
----

All objects have value semantics, but their contents may be accessed
through different pointers referring to the same object.
For example, when calling a function with an array, the array is
passed by value, possibly by making a copy.   To pass a reference,
one must explicitly pass a pointer to the array.  For arrays in
particular, this is different from C.

There is also a built-in string type, which represents immutable
strings of bytes.


Syntax
----

The syntax of statements and expressions in Go borrows from the C tradition;
declarations are loosely derived from the Pascal tradition to allow more
comprehensible composability of types.

Here is a complete example Go program that implements a concurrent prime sieve:


  package main
  
  // Send the sequence 2, 3, 4, ... to channel 'ch'.
  func Generate(ch *chan> int) {
    for i := 2; ; i++ {
      >ch = i  // Send 'i' to channel 'ch'.
    }
  }
  
  // Copy the values from channel 'in' to channel 'out',
  // removing those divisible by 'prime'.
  func Filter(in *chan< int, out *chan> int, prime int) {
    for {
      i := <in;  // Receive value of new variable 'i' from 'in'.
      if i % prime != 0 {
        >out = i  // Send 'i' to channel 'out'.
      }
    }
  }
  
  // The prime sieve: Daisy-chain Filter processes together.
  func Sieve() {
    ch := new(chan int);  // Create a new channel.
    go Generate(ch);  // Start Generate() as a subprocess.
    for {
      prime := <ch;
      printf("%d\n",  prime);
      ch1 := new(chan int);
      go Filter(ch, ch1, prime);
      ch = ch1
    }
  }
  
  func main() {
    Sieve()
  }


Notation
----

The syntax is specified using Extended Backus-Naur Form (EBNF). 
In particular:

- ""  encloses lexical symbols (a backslash precedes a literal quote within a symbol)
- |   separates alternatives
- ()  groups
- []  specifies an option (0 or 1 times)
- {}  specifies repetition (0 to n times)

A production may be referenced from various places in this document
but is usually defined close to its first use.  Productions and code
examples are indented.

Lower-case production names are used to identify productions that cannot
be broken by white space or comments; they are usually tokens. Other
productions are in CamelCase.


Common productions
----

  IdentifierList = identifier { "," identifier } .
  ExpressionList = Expression { "," Expression } .

  QualifiedIdent = [ PackageName "." ] identifier .
  PackageName = identifier .


Source code representation
----

Source code is Unicode text encoded in UTF-8.

Tokenization follows the usual rules.  Source text is case-sensitive.

White space is blanks, newlines, carriage returns, or tabs.

Comments are // to end of line or /* */ without nesting and are treated as white space.

Some Unicode characters (e.g., the character U+00E4) may be representable in
two forms, as a single code point or as two code points.  For simplicity of
implementation, Go treats these as distinct characters.


Characters
----

In the grammar we use the notation

  utf8_char

to refer to an arbitrary Unicode code point encoded in UTF-8.


Digits and Letters
----

  oct_digit = { "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" } .
  dec_digit = { "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" } .
  hex_digit = { "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" |
                "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e" | "E" | "f" | "F" } .
  letter = "A" | "a" | ... "Z" | "z" | "_" .

For simplicity, letters and digits are ASCII.  We may in time allow
Unicode identifiers.


Identifiers
----

An identifier is a name for a program entity such as a variable, a
type, a function, etc. An identifier must not be a reserved word.

  identifier = letter { letter | dec_digit } .

	a
	_x
	ThisIsVariable9


Types
----

A type specifies the set of values that variables of that type may
assume, and the operators that are applicable.

There are basic types and compound types constructed from them.


Basic types
----

Go defines a number of basic types, referred to by their
predeclared type names.  There are signed and unsigned integer
and floating point types:

  bool    the truth values true and false

  uint8   the set of all unsigned 8-bit integers
  uint16  the set of all unsigned 16-bit integers
  uint32  the set of all unsigned 32-bit integers
  unit64  the set of all unsigned 64-bit integers

  byte    alias for uint8

  int8   the set of all signed 8-bit integers, in 2's complement
  int16  the set of all signed 16-bit integers, in 2's complement
  int32  the set of all signed 32-bit integers, in 2's complement
  int64  the set of all signed 64-bit integers, in 2's complement

  float32    the set of all valid IEEE-754 32-bit floating point numbers
  float64    the set of all valid IEEE-754 64-bit floating point numbers
  float80    the set of all valid IEEE-754 80-bit floating point numbers

Additionally, Go declares 4 basic types, uint, int, float, and double,
which are platform-specific.  The bit width of these types corresponds to
the ``natural bit width'' for the respective types for the given
platform. For instance, int is usally the same as int32 on a 32-bit
architecture, or int64 on a 64-bit architecture.  These types are by
definition platform-specific and should be used with the appropriate
caution.

Two reserved words, "true" and "false", represent the
corresponding boolean constant values.

There is also a polymorphic type, "any".  The "any" type can represent
a value of any type.


Numeric literals
----

Integer literals take the usual C form, except for the absence of the
'U', 'L', etc. suffixes, and represent integer constants.  Character
literals are also integer constants.  Similarly, floating point
literals are also C-like, without suffixes and decimal only.

An integer constant represents an abstract integer value of arbitrary
precision.  Only when an integer constant (or arithmetic expression
formed from integer constants) is bound to a typed variable
or constant is it required to fit into a particular size - that of the type
of the variable.  In other words, integer constants and arithmetic
upon them is not subject to overflow; only finalization of integer
constants (and constant expressions) can cause overflow.
It is an error if the value of the constant or expression cannot be
represented correctly in the range of the type of the receiving
variable or constant.  By extension, it is also possible to use
an integer as a floating constant (such as 1 instead of 1.0) if
it can be represented accurately, and vice versa (such as 1e9
instead of 1000000000).

Floating point literals also represent an abstract, ideal floating
point value that is constrained only upon assignment.

  sign = "+" | "-" .
  int_lit = [ sign ] unsigned_int_lit .
  unsigned_int_lit = decimal_int_lit | octal_int_lit | hex_int_lit .
  decimal_int_lit = ( "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" )
                  { dec_digit } .
  octal_int_lit = "0" { oct_digit } .
  hex_int_lit = "0" ( "x" | "X" ) hex_digit { hex_digit } .
  float_lit =  [ sign ] ( fractional_lit | exponential_lit ) .
  fractional_lit = { dec_digit } ( dec_digit "." | "." dec_digit )
                   { dec_digit } [ exponent ] .
  exponential_lit = dec_digit { dec_digit } exponent .
  exponent = ( "e" | "E" ) [ sign ] dec_digit { dec_digit }

  07
  0xFF
  -44
  +3.24e-7

The string type
----

The string type represents the set of string values (strings).
Strings behave like arrays of bytes, with the following properties:

- They are immutable: after creation, it is not possible to change the
  contents of a string.
- No internal pointers: it is illegal to create a pointer to an inner
  element of a string.
- They can be indexed: given string s1, s1[i] is a byte value.
- They can be concatenated: given strings s1 and s2, s1 + s2 is a value
  combining the elements of s1 and s2 in sequence.
- Known length: the length of a string s1 can be obtained by the function/
  operator len(s1).  The length of a string is the number of bytes within.
  Unlike in C, there is no terminal NUL byte.
- Creation 1: a string can be created from an integer value by a conversion;
  the result is a string containing the UTF-8 encoding of that code point.
    string('x') yields "x"; string(0x1234) yields the equivalent of "\u1234"
- Creation 2: a string can by created from an array of integer values (maybe
  just array of bytes) by a conversion
    a [3]byte; a[0] = 'a'; a[1] = 'b'; a[2] = 'c';  string(a) == "abc";


Character and string literals
----

Character and string literals are almost the same as in C, but with
UTF-8 required.  This section is precise but can be skipped on first
reading.

Character and string literals are similar to C except:
  - Octal character escapes are always 3 digits (\077 not \77)
  - Hexadecimal character escapes are always 2 digits (\x07 not \x7)
  - Strings are UTF-8 and represent Unicode
  - `` strings exist; they do not interpret backslashes

The rules are:

  char_lit = "'" ( unicode_value | byte_value ) "'" .
  unicode_value = utf8_char | little_u_value | big_u_value | escaped_char .
  byte_value = octal_byte_value | hex_byte_value .
  octal_byte_value = "\" oct_digit oct_digit oct_digit .
  hex_byte_value = "\" "x" hex_digit hex_digit .
  little_u_value = "\" "u" hex_digit hex_digit hex_digit hex_digit .
  big_u_value = "\" "U" hex_digit hex_digit hex_digit hex_digit
                      hex_digit hex_digit hex_digit hex_digit .
  escaped_char = "\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\" | "'" | "\"" ) .

A unicode_value takes one of four forms:

* The UTF-8 encoding of a Unicode code point.  Since Go source
text is in UTF-8, this is the obvious translation from input
text into Unicode characters.
* The usual list of C backslash escapes: \n \t etc.
* A `little u' value, such as \u12AB.  This represents the Unicode
code point with the corresponding hexadecimal value.  It always
has exactly 4 hexadecimal digits.
* A `big U' value, such as \U00101234.  This represents the
Unicode code point with the corresponding hexadecimal value.
It always has exactly 8 hexadecimal digits.

Some values that can be represented this way are illegal because they
are not valid Unicode code points.  These include values above
0x10FFFF and surrogate halves.

An octal_byte_value contains three octal digits.  A hex_byte_value
contains two hexadecimal digits.  (Note: This differs from C but is
simpler.)

It is erroneous for an octal_byte_value to represent a value larger than 255. 
(By construction, a hex_byte_value cannot.)

A character literal is a form of unsigned integer constant.  Its value
is that of the Unicode code point represented by the text between the
quotes. [Note: the Unicode doesn't look right in the browser.]

    'a'
    'ä'
    '本'
    '\t'
    '\000'
    '\007'
    '\377'
    '\x07'
    '\xff'
    '\u12e4'
    '\U00101234'

String literals come in two forms: double-quoted and back-quoted.
Double-quoted strings have the usual properties; back-quoted strings
do not interpret backslashes at all.

  string_lit = raw_string_lit | interpreted_string_lit .
  raw_string_lit = "`" { utf8_char } "`" .
  interpreted_string_lit = "\"" { unicode_value | byte_value } "\"" .

A string literal has type 'string'.  Its value is constructed by
taking the byte values formed by the successive elements of the
literal.  For byte_values, these are the literal bytes; for
unicode_values, these are the bytes of the UTF-8 encoding of the
corresponding Unicode code points.  Note that
	"\u00FF"
and
	"\xFF"
are
different strings: the first contains the two-byte UTF-8 expansion of
the value 255, while the second contains a single byte of value 255.
The same rules apply to raw string literals, except the contents are
uninterpreted UTF-8.

  `abc`
  `\n`
  "hello, world\n"
  "\n"
  ""
  "Hello, world!\n"
  "日本語"
  "\u65e5本\U00008a9e"
  "\xff\u00FF"

These examples all represent the same string:

    "日本語"  // UTF-8 input text
    `日本語`  // UTF-8 input text as a raw literal
    "\u65e5\u672c\u8a9e"  // The explicit Unicode code points
    "\U000065e5\U0000672c\U00008a9e"  // The explicit Unicode code points
    "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // The explicit UTF-8 bytes

The language does not canonicalize Unicode text or evaluate combining
forms.  The text of source code is passed uninterpreted.

If the source code represents a character as two code points, such as
a combining form involving an accent and a letter, the result will be
an error if placed in a character literal (it is not a single code
point), and will appear as two code points if placed in a string
literal.

More about types
----

The static type of a variable is the type defined by the variable's
declaration.  At run-time, some variables, in particular those of
interface types, can assume a dynamic type, which may be
different at different times during execution.  The dynamic type
of a variable is always compatible with the static type of the
variable.

At any given time, a variable or value has exactly one dynamic
type, which may be the same as the static type.  (They will
differ only if the variable has an interface type or "any" type.)

Compound types may be constructed from other types by
assembling arrays, maps, channels, structures, and functions.

Array, map and struct types are called structured types, all other types
are called unstructured.  A structured type cannot contain itself.

  Type = TypeName | ArrayType | ChannelType | InterfaceType |
         FunctionType | MapType | StructType | PointerType .
  TypeName = QualifiedIdent.


Array types
----

[TODO: this section needs work regarding the precise difference between
static, open and dynamic arrays]

An array is a structured type consisting of a number of elements
all of the same type, called the element type.  The number of
elements of an array is called its length.  The elements of an array
are designated by indices which are integers between 0 and the length - 1.

An array type specifies arrays with a given element type and
an optional array length. If the length is present, it is part of the type.
Arrays without a length specification are called open arrays.
Any array may be assigned to an open array variable with the
same element type. Typically, open arrays are used as
formal parameters for functions.

  ArrayType = "[" [ ArrayLength ] "]" ElementType .
  ArrayLength = Expression .
  ElementType = Type .

  [] uint8
  [2*n] int
  [64] struct { x, y: int32; }
  [1000][1000] float64

The length of an array can be discovered at run time (or compile time, if
its length is a constant) using the built-in special function len():

  len(a)


Map types
----

A map is a structured type consisting of a variable number of entries
called (key, value) pairs. For a given map,
the keys and values must each be of a specific type.
Upon creation, a map is empty and values may be added and removed
during execution.  The number of entries in a map is called its length.
A map whose value type is 'any' can store values of all types.

  MapType = "map" "[" KeyType "]" ValueType .
  KeyType = Type .
  ValueType = Type | "any" .

  map [string] int
  map [struct { pid int; name string }] *chan Buffer
  map [string] any


Struct types
----

Struct types are similar to C structs.

Each field of a struct represents a variable within the data
structure.

  StructType = "struct" "{" [ FieldDeclList [ ";" ] ] "}" .
  FieldDeclList = FieldDecl { ";" FieldDecl } .
  FieldDecl = IdentifierList Type .

    // An empty struct.
    struct {}

    // A struct with 5 fields.
    struct {
        x, y int;
        u float;
        a []int;
        f func();
    }

Compound Literals
----

Literals for compound data structures consist of the type of the constant
followed by a parenthesized expression list.  In effect, they are a
conversion from expression list to compound value.


Array literals
----

Array literals represent array values. All the contained expressions must
be of the same type, which is the element type of the resulting array.

  ArrayLit = ArrayType "(" [ ExpressionList ] ")" .

  []int()
  []int(1, 2, 3)
  []string("x", "y")

Unresolved issues: Are elements converted?  What about length?

Map Literals
----

Map literals represent map values.  They comprise a list of (key, value)
pairs written as successive values.
All keys must have the same type; all values must have the same type.


  MapLit = MapType "(" KeyValueList ")" .
  KeyValueList = [ KeyValue { "," KeyValue } ].
  KeyValue = Expression "," Expression .

  [string]map int("one",1, "two",2)
  [int]map bool(2,true, 3,true, 5,true, 7,true)

Unresolved issues: Are elements converted?
Colon for a separator or comma?

Struct literals
----

Struct literals represent struct constants.  They comprise a list of
expressions that represent the individual fields of a struct.  The
individual expressions must match those of the specified struct type.

  StructLit = StructType "(" [ ExpressionList ] ")" .

  Point(2, 3)
  ColoredPoint(4, 4, "green")
  struct { a, b int } (7, 8)


Pointer types
----

Pointer types are similar to those in C.

  PointerType = "*" Type.

We do not allow pointer arithmetic of any kind.

  *int
  *map[string] *chan

There are no pointer literals.


Channel types
----

A channel provides a mechanism for two concurrently executing functions
to synchronize execution and exchange values of a specified type.

Upon creation, a channel can be used both to send and to receive.
By conversion or assignment, it may be restricted only to send or
to receive; such a restricted channel
is called a 'send channel' or a 'receive channel'.

  ChannelType = "chan" [ "<" | ">" ] ValueType .

    chan any    // a generic channel
    chan int    // a channel that can exchange only ints
    chan> float // a channel that can only be used to send floats
    chan< any   // a channel that can receive (only) values of any type

Channel variables always have type pointer to channel.
It is an error to attempt to use a channel value and in
particular to dereference a channel pointer.

    var ch *chan int;
    ch = new(chan int);  // new returns type *chan int

There are no channel literals.


Function types
----

A function type denotes the set of all functions with the same signature.

A method is a function with a receiver, which is of type pointer to struct.

Functions can return multiple values simultaneously.

  FunctionType = "func" AnonymousSignature .
  AnonymousSignature = [ Receiver "." ] Parameters [ Result ] .
  Receiver = "(" identifier Type ")" .
  Parameters = "(" [ ParameterList ] ")" .
  ParameterList = ParameterSection { "," ParameterSection } .
  ParameterSection = [ IdentifierList ] Type .
  Result = Type | "(" ParameterList ")" .

    // Function types
    func ()
    func (a, b int, z float) bool
    func (a, b int, z float) (success bool)
    func (a, b int, z float) (success bool, result float)

    // Method types
    func (p *T) . ()
    func (p *T) . (a, b int, z float) bool
    func (p *T) . (a, b int, z float) (success bool)
    func (p *T) . (a, b int, z float) (success bool, result float)

A variable can hold only a pointer to a function, not a function value.
In particular, v := func() {} creates a variable of type *func(). To call the
function referenced by v, one writes v(). It is illegal to dereference a
function pointer.


Function Literals
----

Function literals represent anonymous functions.

  FunctionLit = FunctionType Block .
  Block = "{" [ StatementList [ ";" ] ] "}" .

The scope of an identifier declared within a block extends
from the declaration of the identifier (that is, the position
immediately after the identifier) to the end of the block.

A function literal can be invoked
or assigned to a variable of the corresponding function pointer type.
For now, a function literal can reference only its parameters, global
variables, and variables declared within the function literal.

    // Function literal
    func (a, b int, z float) bool { return a*b < int(z); }

    // Method literal
    func (p *T) . (a, b int, z float) bool { return a*b < int(z) + p.x; }

Unresolved issues: Are there method literals? How do you use them?

Methods
----

A method is a function bound to a particular struct type T.  When defined,
a method indicates the type of the struct by declaring a receiver of type
*T.  For instance, given type Point

  type Point struct { x, y float }

the declaration

  func (p *Point) distance(float scale) float {
    return scale * (p.x*p.x + p.y*p.y);
  }

creates a method of type Point.  Note that methods are not declared
within their struct type declaration.  They may appear anywhere and
may be forward-declared for commentary.

When invoked, a method behaves like a function whose first argument
is the receiver, but at the call site the receiver is bound to the method
using the notation

  receiver.method()

For instance, given a Point variable pt, one may call

  pt.distance(3.5)


Interface of a struct
----

The interface of a struct is defined to be the unordered set of methods
associated with that struct.


Interface types
----

An interface type denotes a set of methods.

  InterfaceType = "interface" "{" [ MethodDeclList [ ";" ] ] "}" .
  MethodDeclList = MethodDecl { ";" MethodDecl } .
  MethodDecl = identifier Parameters [ Result ] .

  // A basic file interface.
  type File interface {
    Read(b Buffer) bool;
    Write(b Buffer) bool;
    Close();
  }

Any struct whose interface has, possibly as a subset, the complete
set of methods of an interface I is said to implement interface I.
For instance, if two struct types S1 and S2 have the methods

  func (p *T) Read(b Buffer) bool { return ... }
  func (p *T) Write(b Buffer) bool { return ... }
  func (p *T) Close() { ... }

then the File interface is implemented by both S1 and S2, regardless of
what other methods S1 and S2 may have or share.

All struct types implement the empty interface:

  interface {}

In general, a struct type implements an arbitrary number of interfaces.
For instance, if we have

  type Lock interface {
    lock();
    unlock();
  }

and S1 and S2 also implement

  func (p *T) lock() { ... }
  func (p *T) unlock() { ... }

they implement the Lock interface as well as the File interface.

It is legal to assign a pointer to a struct to a variable of
compatible interface type.  It is legal to assign an interface
variable to any struct pointer variable but if the struct type is
incompatible the result will be nil.

There are no interface literals.


The polymorphic "any" type
----

Given a variable of type "any", one can store any value into it by
plain assignment or implicitly, such as through a function parameter
or channel operation.  Given an "any" variable v storing an underlying
value of type T, one may:

  - copy v's value to another variable of type "any"
  - extract the stored value by an explicit conversion operation T(v)
  - copy v's value to a variable of type T
  
Attempts to convert/extract to an incompatible type will yield nil.

No other operations are defined (yet).

Note that type
	interface {}
is a special case that can match any struct type, while type
	any
can match any type at all, including basic types, arrays, etc.

TODO: details about reflection


Literals
----

  Literal = BasicLit | CompoundLit .
  BasicLit = char_lit | string_lit | int_lit | float_lit | "nil" .
  CompoundLit = ArrayLit | MapLit | StructLit | FunctionLit .


Declarations
----

A declaration associates a name with a language entity such as a type,
constant, variable, or function.

  Declaration = ConstDecl | TypeDecl | VarDecl | FunctionDecl | ExportDecl .


Const declarations
----

A constant declaration gives a name to the value of a constant expression.

  ConstDecl = "const" ( ConstSpec | "(" ConstSpecList [ ";" ] ")" ).
  ConstSpec = identifier [ Type ] "=" Expression .
  ConstSpecList = ConstSpec { ";" ConstSpec }.

  const pi float = 3.14159265
  const e = 2.718281828
  const (
    one int = 1;
    two = 3
  )


Type declarations
----

A type declaration introduces a name as a shorthand for a type.

  TypeDecl = "type" ( TypeSpec | "(" TypeSpecList [ ";" ] ")" ).
  TypeSpec = identifier Type .
  TypeSpecList = TypeSpec { ";" TypeSpec }.


  type IntArray [16] int
  type (
    Point struct { x, y float };
    Polar Point
  )


Variable declarations
----

A variable declaration creates a variable and gives it a type and a name.
It may optionally give the variable an initial value; in some forms of
declaration the type of the initial value defines the type of the variable.

  VarDecl = "var" ( VarSpec | "(" VarSpecList [ ";" ] ")" ) .
  VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
  VarSpecList = VarSpec { ";" VarSpec } .

  var i int
  var u, v, w float
  var k = 0
  var x, y float = -1.0, -2.0
  var (
    i int;
    u, v = 2.0, 3.0
  )

If the expression list is present, it must have the same number of elements
as there are variables in the variable specification.

The syntax

  SimpleVarDecl = identifier ":=" Expression .

is shorthand for

  var identifer = Expression.

  i := 0
  f := func() int { return 7; }
  ch := new(chan int);
  
Also, in some contexts such as if or for statements,
this construct can be used to
declare local temporary variables.


Function and method declarations
----

Functions and methods have a special declaration syntax, slightly
different from the type syntax because an identifier must be present
in the signature. Functions and methods can only be declared
at the global level.

  FunctionDecl = "func" NamedSignature  ( ";" | Block ) .
  NamedSignature = [ Receiver ] identifier Parameters [ Result ] .

  func min(x int, y int) int {
    if x < y {
      return x;
    }
    return y;
  }

  func foo(a, b int, z float) bool {
    return a*b < int(z);
  }


A method is a function that also declares a receiver.

  func (p *T) foo(a, b int, z float) bool {
    return a*b < int(z) + p.x; 
  }

  func (p *Point) Length() float {
    return Math.sqrt(p.x * p.x + p.y * p.y);
  }

  func (p *Point) Scale(factor float) {
    p.x = p.x * factor;
    p.y = p.y * factor;
  }

Functions and methods can be forward declared by omitting the body:

  func foo(a, b int, z float) bool;
  func (p *T) foo(a, b int, z float) bool;


Export declarations
----

Global identifiers may be exported, thus making the
exported identifer visible outside the package.  Another package may
then import the identifier to use it.

Export declarations must only appear at the global level of a
compilation unit and can name only globally-visible identifiers.
That is, one can export global functions, types, and so on but not
local variables or structure fields.

Exporting an identifier makes the identifier visible externally to the
package.  If the identifier represents a type, the type structure is
exported as well.  The exported identifiers may appear later in the
source than the export directive itself, but it is an error to specify
an identifier not declared anywhere in the source file containing the
export directive.

  ExportDecl = "export" ExportIdentifier { "," ExportIdentifier } .
  ExportIdentifier = QualifiedIdent .

  export sin, cos
  export math.abs

TODO: complete this section

TODO: export as a mechanism for public and private struct fields?


Expressions
----

Expression syntax is based on that of C but with fewer precedence levels.

  Expression = BinaryExpr | UnaryExpr | PrimaryExpr .
  BinaryExpr = Expression binary_op Expression .
  UnaryExpr = unary_op Expression .

  PrimaryExpr =
    identifier | Literal | "(" Expression ")" | "iota" |
    Call | Conversion | Allocation |
    Expression "[" Expression [ ":" Expression ] "]" | Expression "." identifier .
  
  Call = Expression "(" [ ExpressionList ] ")" .
  Conversion = TypeName "(" [ ExpressionList ] ")" .
  Allocation = "new" "(" Type [ "," Expression ] ")" .

  binary_op = log_op | rel_op | add_op | mul_op .
  log_op = "||" | "&&" .
  rel_op = "==" | "!=" | "<" | "<=" | ">" | ">=".
  add_op = "+" | "-" | "|" | "^".
  mul_op = "*" | "/" | "%" | "<<" | ">>" | "&".

  unary_op = "+" | "-" | "!" | "^" | "<" | ">" | "*" | "&" .

Field selection ('.') binds tightest, followed by indexing ('[]') and then calls and conversions.
The remaining precedence levels are as follows (in increasing precedence order):

  Precedence    Operator
      1                  ||
      2                  &&
      3                  ==  !=  <  <=  >  >=
      4                  +  -  |  ^
      5                  *  /  %  <<  >>  &
      6                  +  -  !  ^  <  >  *  &  (unary)
    
For integer values, / and % satisfy the following relationship:

    (a / b) * b + a % b == a

and

    (a / b) is "truncated towards zero".

There are no implicit type conversions except for
constants and literals.  In particular, unsigned and signed integer
variables cannot be mixed in an expression without explicit conversion.

The shift operators implement arithmetic shifts for signed integers
and logical shifts for unsigned integers. The properties of negative
shift counts are undefined. Unary '^' corresponds to C '~' (bitwise
complement).

There is no '->' operator. Given a pointer p to a struct, one writes
    p.f
to access field f of the struct. Similarly, given an array or map
pointer, one writes
    p[i]
to access an element.  Given a function pointer, one writes
    p()
to call the function.

Other operators behave as in C.

The "iota" keyword is discussed in the next section.
  
Examples of primary expressions

  x
  2
  (s + ".txt")
  f(3.1415, true)
  Point(1, 2)
  new([]int, 100)
  m["foo"]
  s[i : j + 1]
  obj.color
  Math.sin
  f.p[i].x()

Examples of general expressions

  +x
  23 + 3*x[i]
  x <= f()
  ^a >> b
  f() || g()
  x == y + 1 && <chan_ptr > 0
  

The constant generator 'iota'
----

Within a declaration, each appearance of the keyword 'iota' represents a successive
element of an integer sequence. It is reset to zero whenever the keyword 'const', 'type'
or 'var' introduces a new declaration. For instance, 'iota' can be used to construct
a set of related constants:

  const (
    enum0 = iota;  // sets enum0 to 0, etc.
    enum1 = iota;
    enum2 = iota
  )

  const (
    a = 1 << iota;  // sets a to 1 (iota has been reset)
    b = 1 << iota;  // sets b to 2
    c = 1 << iota;  // sets c to 4
  )
  
  const x = iota;  // sets x to 0
  const y = iota;  // sets y to 0


Statements
----

Statements control execution.

  Statement =
    [ LabelDecl ] ( StructuredStat | UnstructuredStat ) .
    
  StructuredStat =
    Block | IfStat | SwitchStat | ForStat | RangeStat .

  UnstructuredStat =
    Declaration | SimpleVarDecl |
    SimpleStat | GoStat | ReturnStat | BreakStat | ContinueStat | GotoStat .
    
  SimpleStat =
    ExpressionStat | IncDecStat | Assignment | SimpleVarDecl .
    
    
Statement lists
----

Semicolons are used to separate individual statements of a statement list.
They are optional after a statement that ends with a closing curly brace '}'.

  StatementList =
    StructuredStat |
    UnstructuredStat |
    StructuredStat [ ";" ] StatementList |
    UnstructuredStat ";" StatementList . 
    
TODO: define optional semicolons precisely


Expression statements
----

  ExpressionStat = Expression .

  f(x+y)


IncDec statements
----

  IncDecStat = Expression ( "++" | "--" ) .

  a[i]++

Note that ++ and -- are not operators for expressions.


Assignments
----

  Assignment = SingleAssignment | TupleAssignment | Send .
  SingleAssignment = PrimaryExpr assign_op Expression .
  TupleAssignment = PrimaryExprList assign_op ExpressionList .
  PrimaryExprList = PrimaryExpr { "," PrimaryExpr } .
  Send = ">" Expression "=" Expression .
  
  assign_op = [ add_op | mul_op ] "=" .

The left-hand side must be an l-value such as a variable, pointer indirection,
or an array indexing.

  x = 1
  *p = f()
  a[i] = 23
  
As in C, arithmetic binary operators can be combined with assignments:

  j <<= 2

A tuple assignment assigns the individual elements of a multi-valued operation,
such as function evaluation or some channel and map operations, into individual
variables. For instance, a tuple assignment such as

  v1, v2, v3 = e1, e2, e3
  
assigns the expressions e1, e2, e3 to temporaries and then assigns the temporaries
to the variables v1, v2, v3. Thus

  a, b = b, a

exchanges the values of a and b. The tuple assignment

  x, y = f()

calls the function f, which must return two values, and assigns them to x and y.
As a special case, retrieving a value from a map, when written as a two-element
tuple assignment, assign a value and a boolean. If the value is present in the map,
the value is assigned and the second, boolean variable is set to true. Otherwise,
the variable is unchanged, and the boolean value is set to false.
  
  value, present = map_var[key]
  
Analogously, receiving a value from a channel can be written as a tuple assignment.

  value, success = <chan_var
  
If the receive operation would block, the boolean is set to false.
This provides a mechanism to avoid blocking on a receive operation.

Sending on a channel is a form of assignment. The left hand side expression
must denote a channel pointer value.

  >chan_ptr = value
  
In assignments, the type of the expression must match the type of the left-hand side.


Go statements
----

A go statement starts the execution of a function as an independent
concurrent thread of control within the same address space.  Unlike
with a function, the next line of the program does not wait for the
function to complete.

  GoStat = "go" Call .


  go Server()
  go func(ch chan> bool) { for { sleep(10); >ch = true; }} (c)


Return statements
----

A return statement terminates execution of the containing function
and optionally provides a result value or values to the caller.

  ReturnStat = "return" [ ExpressionList ] .


There are two ways to return values from a function.  The first is to
explicitly list the return value or values in the return statement:

  func simple_f() int {
    return 2;
  }

  func complex_f1() (float, float) {
    return -7.0, -4.0;
  }

The second is to provide names for the return values and assign them
explicitly in the function; the return statement will then provide no
values:

  func complex_f2() (re float, im float) {
    re = 7.0;
    im = 4.0;
    return;
  }

It is legal to name the return values in the declaration even if the
first form of return statement is used:

  func complex_f2() (re float, im float) {
    return 7.0, 4.0;
  }


If statements
----

If statements have the traditional form except that the
condition need not be parenthesized and the "then" statement
must be in brace brackets.

  IfStat = "if" [ SimpleStat ";" ] Expression Block [ "else" Statement ] .

  if x > 0 {
    return true;
  }
  
An if statement may include the declaration of a single temporary variable.
The scope of the declared variable extends to the end of the if statement, and
the variable is initialized once before the statement is entered. 

  if x := f(); x < y {
    return x;
  } else if x > z {
    return z;
  } else {
    return y;
  }
  

Switch statements
----

Switches provide multi-way execution.

  SwitchStat = "switch" [ [ SimpleStat ";" ] "Expression ] "{" { CaseClause } "}" .
  CaseClause = CaseList StatementList [ ";" ] [ "fallthrough" [ ";" ] ] .
  CaseList = Case { Case } .
  Case = ( "case" ExpressionList | "default" ) ":" .

There can be at most one default case in a switch statement.

The "fallthrough" keyword indicates that the control should flow from
the end of this case clause to the first statement of the next clause.

The expressions do not need to be constants. They will
be evaluated top to bottom until the first successful non-default case is reached.
If none matches and there is a default case, the statements of the default
case are executed.

  switch tag {
  default: s3()
  case 0, 1: s1()
  case 2: s2()
  }

A switch statement may include the declaration of a single temporary variable.
The scope of the declared variable extends to the end of the switch statement, and
the variable is initialized once before the switch is entered. 

  switch x := f(); true {
  case x < 0: return -x
  default: return x
  }
  
Cases do not fall through unless explicitly marked with a "fallthrough" statement.

  switch a {
  case 1:
    b();
    fallthrough
  case 2:
    c();
  }

If the expression is omitted, it is equivalent to "true".

  switch {
  case x < y: f1();
  case x < z: f2();
  case x == 4: f3();
  }


For statements
----

For statements are a combination of the "for" and "while" loops of C.

  ForStat = "for" [ Condition | ForClause ] Block .
  ForClause = [ InitStat ] ";" [ Condition ] ";" [ PostStat ] .
  
  InitStat = SimpleStat .
  Condition = Expression .
  PostStat = SimpleStat .

A SimpleStat is a simple statement such as an assignment, a SimpleVarDecl,
or an increment or decrement statement. Therefore one may declare a loop
variable in the init statement.

  for i := 0; i < 10; i++ {
    printf("%d\n", i)
  }

A for statement with just a condition executes until the condition becomes
false. Thus it is the same as C's while statement.

  for a < b {
    a *= 2
  }

If the condition is absent, it is equivalent to "true".

  for {
    f()
  }


Range statements
----

Range statements are a special control structure for iterating over
the contents of arrays and maps.

  RangeStat = "range" IdentifierList ":=" RangeExpression Block .
  RangeExpression = Expression .

A range expression must evaluate to an array, map or string. The identifier list must contain
either one or two identifiers. If the range expression is a map, a single identifier is declared
to range over the keys of the map; two identifiers range over the keys and corresponding
values. For arrays and strings, the behavior is analogous for integer indices (the keys) and
array elements (the values).

  a := []int(1, 2, 3);
  m := [string]map int("fo",2, "foo",3, "fooo",4)

  range i := a {
    f(a[i]);
  }

  range v, i := a {
    f(v);
  }

  range k, v := m {
    assert(len(k) == v);
  }

TODO: is this right?

Break statements
----

Within a for or switch statement, a break statement terminates execution of
the innermost for or switch statement.

  BreakStat = "break" [ identifier ].

If there is an identifier, it must be the label name of an enclosing
for or switch
statement, and that is the one whose execution terminates.

  L: for i < n {
    switch i {
    case 5: break L
    }
  }


Continue statements
----

Within a for loop a continue statement begins the next iteration of the
loop at the post statement.

  ContinueStat = "continue" [ identifier ].

The optional identifier is analogous to that of a break statement.


Label declaration
----

A label declaration serves as the target of a goto, break or continue statement.

  LabelDecl = identifier ":" .

  Error:


Goto statements
----

A goto statement transfers control to the corresponding label statement.

  GotoStat = "goto" identifier .

  goto Error

Executing the goto statement must not cause any variables to come into
scope that were not already in scope at the point of the goto.  For
instance, this example:

	goto L;  // BAD
	v := 3;
	L:

is erroneous because the jump to label L skips the creation of v.

Packages
----

Every source file identifies the package to which it belongs.
The file must begin with a package clause.

  PackageClause = "package" PackageName .

  package Math


Import declarations
----

A program can gain access to exported items from another package
through an import declaration:

  ImportDecl = "import" [ "." | PackageName ] PackageFileName .
  PackageFileName = string_lit .

An import statement makes the exported contents of the named
package file accessible in this package.

In the following discussion, assume we have a package in the
file "/lib/math", called package Math, which exports functions sin
and cos.

In the general form, with an explicit package name, the import
statement declares that package name as an identifier whose
contents are the exported elements of the imported package.
For instance, after

  import M "/lib/math"

the contents of the package /lib/math can be accessed by
M.cos, M.sin, etc.

In its simplest form, with no package name, the import statement
implicitly uses the imported package name itself as the local
package name.  After

  import "/lib/math"

the contents are accessible by Math.sin, Math.cos.

Finally, if instead of a package name the import statement uses
an explicit period, the contents of the imported package are added
to the current package. After

  import . "/lib/math"

the contents are accessible by sin and cos.  In this instance, it is
an error if the import introduces name conflicts.


Program
----

A program is package clause, optionally followed by import declarations,
followed by a series of declarations.

  Program = PackageClause { ImportDecl } { Declaration } .

TODO
----

- TODO: type switch?
- TODO: select
- TODO: words about slices
- TODO: what is nil? do we type-test by a nil conversion or something else?

