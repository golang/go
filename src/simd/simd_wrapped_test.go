// Code generated by x/arch/internal/simdgen using 'go run . -xedPath $XED_PATH -o godefs -goroot $GOROOT go.yaml types.yaml categories.yaml'; DO NOT EDIT.

//go:build goexperiment.simd

package simd_test

import (
	"simd"
	"testing"
)

func testFloat32x4Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "AddSub":
		gotv = vec0.AddSub(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "DotProdBroadcast":
		gotv = vec0.DotProdBroadcast(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x4())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask32x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x4())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask32x4())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask32x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x4())

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt32x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x4()

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	vec2 := simd.LoadFloat32x4Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadFloat32x4Slice(v1)
	vec2 := simd.LoadFloat32x4Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask32x4())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask32x4())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4Unary(t *testing.T, v0 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Ceil":
		gotv = vec0.Ceil()
	case "Floor":
		gotv = vec0.Floor()
	case "Round":
		gotv = vec0.Round()
	case "Sqrt":
		gotv = vec0.Sqrt()
	case "Trunc":
		gotv = vec0.Trunc()

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x4UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x4
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask32x4())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask32x4())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask32x4())

	default:
		t.Errorf("Unknown method: Float32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "AddSub":
		gotv = vec0.AddSub(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "DotProdBroadcast":
		gotv = vec0.DotProdBroadcast(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x8())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask32x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x8())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask32x8())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask32x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x8())

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt32x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x8()

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	vec2 := simd.LoadFloat32x8Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadFloat32x8Slice(v1)
	vec2 := simd.LoadFloat32x8Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask32x8())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask32x8())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8Unary(t *testing.T, v0 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Ceil":
		gotv = vec0.Ceil()
	case "Floor":
		gotv = vec0.Floor()
	case "Round":
		gotv = vec0.Round()
	case "Sqrt":
		gotv = vec0.Sqrt()
	case "Trunc":
		gotv = vec0.Trunc()

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x8UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x8
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask32x8())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask32x8())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask32x8())

	default:
		t.Errorf("Unknown method: Float32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16Binary(t *testing.T, v0 []float32, v1 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16BinaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x16())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask32x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x16())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask32x16())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask32x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x16())

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16Compare(t *testing.T, v0 []float32, v1 []float32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt32x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x16()

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16MaskedCompare(t *testing.T, v0 []float32, v1 []float32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16Ternary(t *testing.T, v0 []float32, v1 []float32, v2 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	vec2 := simd.LoadFloat32x16Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16TernaryMasked(t *testing.T, v0 []float32, v1 []float32, v2 []float32, v3 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadFloat32x16Slice(v1)
	vec2 := simd.LoadFloat32x16Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask32x16())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask32x16())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16Unary(t *testing.T, v0 []float32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Sqrt":
		gotv = vec0.Sqrt()

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat32x16UnaryMasked(t *testing.T, v0 []float32, v1 []int32, want []float32, which string) {
	t.Helper()
	var gotv simd.Float32x16
	got := make([]float32, len(want))
	vec0 := simd.LoadFloat32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask32x16())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask32x16())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask32x16())

	default:
		t.Errorf("Unknown method: Float32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "AddSub":
		gotv = vec0.AddSub(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "DotProdBroadcast":
		gotv = vec0.DotProdBroadcast(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x2())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask64x2())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x2())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x2())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask64x2())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask64x2())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x2())

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x2()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x2()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt64x2()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x2()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x2()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x2()

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	vec2 := simd.LoadFloat64x2Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadFloat64x2Slice(v1)
	vec2 := simd.LoadFloat64x2Slice(v2)
	vec3 := simd.LoadInt64x2Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask64x2())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask64x2())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask64x2())

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2Unary(t *testing.T, v0 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Ceil":
		gotv = vec0.Ceil()
	case "Floor":
		gotv = vec0.Floor()
	case "Round":
		gotv = vec0.Round()
	case "Sqrt":
		gotv = vec0.Sqrt()
	case "Trunc":
		gotv = vec0.Trunc()

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x2UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x2
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask64x2())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask64x2())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask64x2())

	default:
		t.Errorf("Unknown method: Float64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "AddSub":
		gotv = vec0.AddSub(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x4())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask64x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x4())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask64x4())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask64x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x4())

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt64x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x4()

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	vec2 := simd.LoadFloat64x4Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadFloat64x4Slice(v1)
	vec2 := simd.LoadFloat64x4Slice(v2)
	vec3 := simd.LoadInt64x4Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask64x4())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask64x4())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask64x4())

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4Unary(t *testing.T, v0 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Ceil":
		gotv = vec0.Ceil()
	case "Floor":
		gotv = vec0.Floor()
	case "Round":
		gotv = vec0.Round()
	case "Sqrt":
		gotv = vec0.Sqrt()
	case "Trunc":
		gotv = vec0.Trunc()

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x4UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x4
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask64x4())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask64x4())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask64x4())

	default:
		t.Errorf("Unknown method: Float64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8Binary(t *testing.T, v0 []float64, v1 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Div":
		gotv = vec0.Div(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Mul":
		gotv = vec0.Mul(vec1)
	case "MulByPowOf2":
		gotv = vec0.MulByPowOf2(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8BinaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x8())
	case "DivMasked":
		gotv = vec0.DivMasked(vec1, vec2.AsMask64x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x8())
	case "MulByPowOf2Masked":
		gotv = vec0.MulByPowOf2Masked(vec1, vec2.AsMask64x8())
	case "MulMasked":
		gotv = vec0.MulMasked(vec1, vec2.AsMask64x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x8())

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8Compare(t *testing.T, v0 []float64, v1 []float64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
	case "IsNan":
		gotv = vec0.IsNan(vec1).AsInt64x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x8()

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8MaskedCompare(t *testing.T, v0 []float64, v1 []float64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "IsNanMasked":
		gotv = vec0.IsNanMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8Ternary(t *testing.T, v0 []float64, v1 []float64, v2 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	vec2 := simd.LoadFloat64x8Slice(v2)
	switch which {
	case "FusedMultiplyAdd":
		gotv = vec0.FusedMultiplyAdd(vec1, vec2)
	case "FusedMultiplyAddSub":
		gotv = vec0.FusedMultiplyAddSub(vec1, vec2)
	case "FusedMultiplySubAdd":
		gotv = vec0.FusedMultiplySubAdd(vec1, vec2)

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8TernaryMasked(t *testing.T, v0 []float64, v1 []float64, v2 []float64, v3 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadFloat64x8Slice(v1)
	vec2 := simd.LoadFloat64x8Slice(v2)
	vec3 := simd.LoadInt64x8Slice(v3)
	switch which {
	case "FusedMultiplyAddMasked":
		gotv = vec0.FusedMultiplyAddMasked(vec1, vec2, vec3.AsMask64x8())
	case "FusedMultiplyAddSubMasked":
		gotv = vec0.FusedMultiplyAddSubMasked(vec1, vec2, vec3.AsMask64x8())
	case "FusedMultiplySubAddMasked":
		gotv = vec0.FusedMultiplySubAddMasked(vec1, vec2, vec3.AsMask64x8())

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8Unary(t *testing.T, v0 []float64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	switch which {
	case "ApproximateReciprocal":
		gotv = vec0.ApproximateReciprocal()
	case "ApproximateReciprocalOfSqrt":
		gotv = vec0.ApproximateReciprocalOfSqrt()
	case "Sqrt":
		gotv = vec0.Sqrt()

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testFloat64x8UnaryMasked(t *testing.T, v0 []float64, v1 []int64, want []float64, which string) {
	t.Helper()
	var gotv simd.Float64x8
	got := make([]float64, len(want))
	vec0 := simd.LoadFloat64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	switch which {
	case "ApproximateReciprocalMasked":
		gotv = vec0.ApproximateReciprocalMasked(vec1.AsMask64x8())
	case "ApproximateReciprocalOfSqrtMasked":
		gotv = vec0.ApproximateReciprocalOfSqrtMasked(vec1.AsMask64x8())
	case "SqrtMasked":
		gotv = vec0.SqrtMasked(vec1.AsMask64x8())

	default:
		t.Errorf("Unknown method: Float64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x16())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x16())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x16())

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x16()

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16Unary(t *testing.T, v0 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x16UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask8x16())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x16())

	default:
		t.Errorf("Unknown method: Int8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x32())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x32())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x32())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x32())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x32())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x32())

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x32()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x32()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x32()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x32()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x32()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x32()

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32Unary(t *testing.T, v0 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x32UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask8x32())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x32())

	default:
		t.Errorf("Unknown method: Int8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64Binary(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64BinaryMasked(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x64())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x64())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x64())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x64())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x64())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x64())

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64Compare(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x64()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x64()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x64()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x64()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x64()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x64()

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64MaskedCompare(t *testing.T, v0 []int8, v1 []int8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64Unary(t *testing.T, v0 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt8x64UnaryMasked(t *testing.T, v0 []int8, v1 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadInt8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask8x64())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x64())

	default:
		t.Errorf("Unknown method: Int8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedPairwiseAdd":
		gotv = vec0.SaturatedPairwiseAdd(vec1)
	case "SaturatedPairwiseSub":
		gotv = vec0.SaturatedPairwiseSub(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x8())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x8())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask16x8())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x8())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x8())

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "PairDotProdMasked":
		gotv = vec0.PairDotProdMasked(vec1, vec2.AsMask16x8())

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	switch which {
	case "PairDotProd":
		gotv = vec0.PairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x8()

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8Ternary(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8TernaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, v3 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	vec3 := simd.LoadInt16x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x8())

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8Unary(t *testing.T, v0 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x8UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask16x8())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x8())

	default:
		t.Errorf("Unknown method: Int16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedPairwiseAdd":
		gotv = vec0.SaturatedPairwiseAdd(vec1)
	case "SaturatedPairwiseSub":
		gotv = vec0.SaturatedPairwiseSub(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x16())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x16())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask16x16())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x16())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x16())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x16())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x16())

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "PairDotProdMasked":
		gotv = vec0.PairDotProdMasked(vec1, vec2.AsMask16x16())

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	switch which {
	case "PairDotProd":
		gotv = vec0.PairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x16()

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16Ternary(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16TernaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, v3 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	vec3 := simd.LoadInt16x16Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x16())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x16())

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16Unary(t *testing.T, v0 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x16UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask16x16())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x16())

	default:
		t.Errorf("Unknown method: Int16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32Binary(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32BinaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x32())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x32())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x32())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x32())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask16x32())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x32())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x32())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x32())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x32())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x32())

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32BinaryMaskedWiden(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "PairDotProdMasked":
		gotv = vec0.PairDotProdMasked(vec1, vec2.AsMask16x32())

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32BinaryWiden(t *testing.T, v0 []int16, v1 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	switch which {
	case "PairDotProd":
		gotv = vec0.PairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32Compare(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x32()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x32()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x32()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x32()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x32()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x32()

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32MaskedCompare(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32Ternary(t *testing.T, v0 []int16, v1 []int16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32TernaryMasked(t *testing.T, v0 []int16, v1 []int16, v2 []int16, v3 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	vec3 := simd.LoadInt16x32Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x32())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x32())

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32Unary(t *testing.T, v0 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt16x32UnaryMasked(t *testing.T, v0 []int16, v1 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadInt16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask16x32())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x32())

	default:
		t.Errorf("Unknown method: Int16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x4())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x4())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x4())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask32x4())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x4())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x4())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x4())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x4())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x4())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x4())

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4BinaryWiden(t *testing.T, v0 []int32, v1 []int32, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x4()

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Int16x8Int16x8Int32x4(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "PairDotProdAccumulate":
		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
	case "SaturatedPairDotProdAccumulate":
		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Int16x8Int16x8Mask32x4Int32x4(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "PairDotProdAccumulateMasked":
		gotv = vec0.PairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())
	case "SaturatedPairDotProdAccumulateMasked":
		gotv = vec0.SaturatedPairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Ternary(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4TernaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x4())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Uint8x16Int8x16Int32x4(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Uint8x16Int8x16Mask32x4Int32x4(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4Unary(t *testing.T, v0 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x4UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask32x4())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x4())

	default:
		t.Errorf("Unknown method: Int32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sign":
		gotv = vec0.Sign(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x8())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x8())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x8())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask32x8())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x8())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x8())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x8())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x8())

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8BinaryWiden(t *testing.T, v0 []int32, v1 []int32, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x8()

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Int16x16Int16x16Int32x8(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "PairDotProdAccumulate":
		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
	case "SaturatedPairDotProdAccumulate":
		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Int16x16Int16x16Mask32x8Int32x8(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "PairDotProdAccumulateMasked":
		gotv = vec0.PairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())
	case "SaturatedPairDotProdAccumulateMasked":
		gotv = vec0.SaturatedPairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Ternary(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8TernaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Uint8x32Int8x32Int32x8(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Uint8x32Int8x32Mask32x8Int32x8(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8Unary(t *testing.T, v0 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x8UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask32x8())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x8())

	default:
		t.Errorf("Unknown method: Int32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Binary(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16BinaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x16())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x16())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x16())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask32x16())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x16())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x16())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x16())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x16())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x16())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x16())

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Compare(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x16()

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Int16x32Int16x32Int32x16(t *testing.T, v0 []int32, v1 []int16, v2 []int16, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "PairDotProdAccumulate":
		gotv = vec0.PairDotProdAccumulate(vec1, vec2)
	case "SaturatedPairDotProdAccumulate":
		gotv = vec0.SaturatedPairDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Int16x32Int16x32Mask32x16Int32x16(t *testing.T, v0 []int32, v1 []int16, v2 []int16, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "PairDotProdAccumulateMasked":
		gotv = vec0.PairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())
	case "SaturatedPairDotProdAccumulateMasked":
		gotv = vec0.SaturatedPairDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16MaskedCompare(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Ternary(t *testing.T, v0 []int32, v1 []int32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16TernaryMasked(t *testing.T, v0 []int32, v1 []int32, v2 []int32, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x16())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Uint8x64Int8x64Int32x16(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Uint8x64Int8x64Mask32x16Int32x16(t *testing.T, v0 []int32, v1 []uint8, v2 []int8, v3 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16Unary(t *testing.T, v0 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt32x16UnaryMasked(t *testing.T, v0 []int32, v1 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadInt32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask32x16())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x16())

	default:
		t.Errorf("Unknown method: Int32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x2())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x2())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x2())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x2())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x2())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x2())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask64x2())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x2())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x2())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x2())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x2())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x2())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x2())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x2())

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x2()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x2()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x2()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x2()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x2()

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2Ternary(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2TernaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, v3 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	vec3 := simd.LoadInt64x2Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x2())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x2())

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2Unary(t *testing.T, v0 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x2UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask64x2())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x2())

	default:
		t.Errorf("Unknown method: Int64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x4())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x4())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x4())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x4())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask64x4())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x4())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x4())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x4())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x4())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x4())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x4())

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x4()

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4Ternary(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4TernaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, v3 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	vec3 := simd.LoadInt64x4Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x4())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x4())

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4Unary(t *testing.T, v0 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x4UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask64x4())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x4())

	default:
		t.Errorf("Unknown method: Int64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8Binary(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "MulLow":
		gotv = vec0.MulLow(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8BinaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x8())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x8())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x8())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x8())
	case "MulLowMasked":
		gotv = vec0.MulLowMasked(vec1, vec2.AsMask64x8())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x8())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x8())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x8())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x8())

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8Compare(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x8()

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8MaskedCompare(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8Ternary(t *testing.T, v0 []int64, v1 []int64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8TernaryMasked(t *testing.T, v0 []int64, v1 []int64, v2 []int64, v3 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	vec3 := simd.LoadInt64x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x8())

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8Unary(t *testing.T, v0 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	switch which {
	case "Absolute":
		gotv = vec0.Absolute()
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testInt64x8UnaryMasked(t *testing.T, v0 []int64, v1 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadInt64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	switch which {
	case "AbsoluteMasked":
		gotv = vec0.AbsoluteMasked(vec1.AsMask64x8())
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x8())

	default:
		t.Errorf("Unknown method: Int64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x16
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "GaloisFieldMul":
		gotv = vec0.GaloisFieldMul(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x16
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x16())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask8x16())
	case "GaloisFieldMulMasked":
		gotv = vec0.GaloisFieldMulMasked(vec1, vec2.AsMask8x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x16())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x16())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x16())

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x16()

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16Int8x16Int16x8(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	switch which {
	case "SaturatedUnsignedSignedPairDotProd":
		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16Int8x16Mask16x8Int16x8(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedPairDotProdMasked":
		gotv = vec0.SaturatedUnsignedSignedPairDotProdMasked(vec1, vec2.AsMask16x8())

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x16
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x16()).AsInt8x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x16()).AsInt8x16()

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x16
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x16UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x16
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x16Slice(v0)
	vec1 := simd.LoadInt8x16Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x16())

	default:
		t.Errorf("Unknown method: Uint8x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x32
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "GaloisFieldMul":
		gotv = vec0.GaloisFieldMul(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x32
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x32())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask8x32())
	case "GaloisFieldMulMasked":
		gotv = vec0.GaloisFieldMulMasked(vec1, vec2.AsMask8x32())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x32())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x32())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x32())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x32())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x32())

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x32()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x32()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x32()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x32()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x32()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x32()

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32Int8x32Int16x16(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	switch which {
	case "SaturatedUnsignedSignedPairDotProd":
		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32Int8x32Mask16x16Int16x16(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedPairDotProdMasked":
		gotv = vec0.SaturatedUnsignedSignedPairDotProdMasked(vec1, vec2.AsMask16x16())

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x32
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x32()).AsInt8x32()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x32()).AsInt8x32()

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x32
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x32UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x32
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x32Slice(v0)
	vec1 := simd.LoadInt8x32Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x32())

	default:
		t.Errorf("Unknown method: Uint8x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64Binary(t *testing.T, v0 []uint8, v1 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x64
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "GaloisFieldMul":
		gotv = vec0.GaloisFieldMul(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64BinaryMasked(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x64
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask8x64())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask8x64())
	case "GaloisFieldMulMasked":
		gotv = vec0.GaloisFieldMulMasked(vec1, vec2.AsMask8x64())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask8x64())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask8x64())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask8x64())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask8x64())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask8x64())

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64Compare(t *testing.T, v0 []uint8, v1 []uint8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt8x64()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt8x64()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt8x64()
	case "Less":
		gotv = vec0.Less(vec1).AsInt8x64()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt8x64()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt8x64()

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64Int8x64Int16x32(t *testing.T, v0 []uint8, v1 []int8, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	switch which {
	case "SaturatedUnsignedSignedPairDotProd":
		gotv = vec0.SaturatedUnsignedSignedPairDotProd(vec1)

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64Int8x64Mask16x32Int16x32(t *testing.T, v0 []uint8, v1 []int8, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedPairDotProdMasked":
		gotv = vec0.SaturatedUnsignedSignedPairDotProdMasked(vec1, vec2.AsMask16x32())

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64MaskedCompare(t *testing.T, v0 []uint8, v1 []uint8, v2 []int8, want []int8, which string) {
	t.Helper()
	var gotv simd.Int8x64
	got := make([]int8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask8x64()).AsInt8x64()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask8x64()).AsInt8x64()

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64Unary(t *testing.T, v0 []uint8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x64
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint8x64UnaryMasked(t *testing.T, v0 []uint8, v1 []int8, want []uint8, which string) {
	t.Helper()
	var gotv simd.Uint8x64
	got := make([]uint8, len(want))
	vec0 := simd.LoadUint8x64Slice(v0)
	vec1 := simd.LoadInt8x64Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask8x64())

	default:
		t.Errorf("Unknown method: Uint8x64.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x8())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask16x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x8())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x8())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x8())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x8())

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x8()

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x8
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	vec2 := simd.LoadInt16x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x8()).AsInt16x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x8()).AsInt16x8()

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8Ternary(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	vec2 := simd.LoadUint16x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8TernaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, v3 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadUint16x8Slice(v1)
	vec2 := simd.LoadUint16x8Slice(v2)
	vec3 := simd.LoadInt16x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x8())

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x8UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x8
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x8Slice(v0)
	vec1 := simd.LoadInt16x8Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x8())

	default:
		t.Errorf("Unknown method: Uint16x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x16())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask16x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x16())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x16())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x16())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x16())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x16())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x16())

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x16()

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x16
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	vec2 := simd.LoadInt16x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x16()).AsInt16x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x16()).AsInt16x16()

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16Ternary(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	vec2 := simd.LoadUint16x16Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16TernaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, v3 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadUint16x16Slice(v1)
	vec2 := simd.LoadUint16x16Slice(v2)
	vec3 := simd.LoadInt16x16Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x16())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x16())

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x16UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x16
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x16Slice(v0)
	vec1 := simd.LoadInt16x16Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x16())

	default:
		t.Errorf("Unknown method: Uint16x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32Binary(t *testing.T, v0 []uint16, v1 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "Average":
		gotv = vec0.Average(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulHigh":
		gotv = vec0.MulHigh(vec1)
	case "SaturatedAdd":
		gotv = vec0.SaturatedAdd(vec1)
	case "SaturatedSub":
		gotv = vec0.SaturatedSub(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32BinaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask16x32())
	case "AverageMasked":
		gotv = vec0.AverageMasked(vec1, vec2.AsMask16x32())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask16x32())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask16x32())
	case "MulHighMasked":
		gotv = vec0.MulHighMasked(vec1, vec2.AsMask16x32())
	case "SaturatedAddMasked":
		gotv = vec0.SaturatedAddMasked(vec1, vec2.AsMask16x32())
	case "SaturatedSubMasked":
		gotv = vec0.SaturatedSubMasked(vec1, vec2.AsMask16x32())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask16x32())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask16x32())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask16x32())

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32Compare(t *testing.T, v0 []uint16, v1 []uint16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt16x32()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt16x32()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt16x32()
	case "Less":
		gotv = vec0.Less(vec1).AsInt16x32()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt16x32()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt16x32()

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32MaskedCompare(t *testing.T, v0 []uint16, v1 []uint16, v2 []int16, want []int16, which string) {
	t.Helper()
	var gotv simd.Int16x32
	got := make([]int16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	vec2 := simd.LoadInt16x32Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask16x32()).AsInt16x32()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask16x32()).AsInt16x32()

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32Ternary(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	vec2 := simd.LoadUint16x32Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32TernaryMasked(t *testing.T, v0 []uint16, v1 []uint16, v2 []uint16, v3 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadUint16x32Slice(v1)
	vec2 := simd.LoadUint16x32Slice(v2)
	vec3 := simd.LoadInt16x32Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x32())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask16x32())

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32Unary(t *testing.T, v0 []uint16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint16x32UnaryMasked(t *testing.T, v0 []uint16, v1 []int16, want []uint16, which string) {
	t.Helper()
	var gotv simd.Uint16x32
	got := make([]uint16, len(want))
	vec0 := simd.LoadUint16x32Slice(v0)
	vec1 := simd.LoadInt16x32Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask16x32())

	default:
		t.Errorf("Unknown method: Uint16x32.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x4())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x4())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x4())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x4())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x4())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x4())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x4())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x4())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x4())

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4BinaryWiden(t *testing.T, v0 []uint32, v1 []uint32, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	switch which {
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x4()

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x4
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	vec2 := simd.LoadInt32x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x4()).AsInt32x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x4()).AsInt32x4()

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Ternary(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	vec2 := simd.LoadUint32x4Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4TernaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint32x4Slice(v1)
	vec2 := simd.LoadUint32x4Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x4())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Uint8x16Int8x16Mask32x4Uint32x4(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	vec3 := simd.LoadInt32x4Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x4())

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Uint8x16Int8x16Uint32x4(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadUint8x16Slice(v1)
	vec2 := simd.LoadInt8x16Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x4UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x4
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x4Slice(v0)
	vec1 := simd.LoadInt32x4Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x4())

	default:
		t.Errorf("Unknown method: Uint32x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "PairwiseAdd":
		gotv = vec0.PairwiseAdd(vec1)
	case "PairwiseSub":
		gotv = vec0.PairwiseSub(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x8())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x8())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x8())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x8())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x8())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x8())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x8())

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8BinaryWiden(t *testing.T, v0 []uint32, v1 []uint32, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	switch which {
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x8()

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x8
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	vec2 := simd.LoadInt32x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x8()).AsInt32x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x8()).AsInt32x8()

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Ternary(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	vec2 := simd.LoadUint32x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8TernaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint32x8Slice(v1)
	vec2 := simd.LoadUint32x8Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Uint8x32Int8x32Mask32x8Uint32x8(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	vec3 := simd.LoadInt32x8Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x8())

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Uint8x32Int8x32Uint32x8(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadUint8x32Slice(v1)
	vec2 := simd.LoadInt8x32Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x8UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x8
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x8Slice(v0)
	vec1 := simd.LoadInt32x8Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x8())

	default:
		t.Errorf("Unknown method: Uint32x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Binary(t *testing.T, v0 []uint32, v1 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16BinaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask32x16())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask32x16())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask32x16())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask32x16())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask32x16())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask32x16())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask32x16())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask32x16())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask32x16())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask32x16())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask32x16())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask32x16())

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Compare(t *testing.T, v0 []uint32, v1 []uint32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt32x16()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt32x16()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt32x16()
	case "Less":
		gotv = vec0.Less(vec1).AsInt32x16()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt32x16()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt32x16()

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16MaskedCompare(t *testing.T, v0 []uint32, v1 []uint32, v2 []int32, want []int32, which string) {
	t.Helper()
	var gotv simd.Int32x16
	got := make([]int32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	vec2 := simd.LoadInt32x16Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask32x16()).AsInt32x16()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask32x16()).AsInt32x16()

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Ternary(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	vec2 := simd.LoadUint32x16Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16TernaryMasked(t *testing.T, v0 []uint32, v1 []uint32, v2 []uint32, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint32x16Slice(v1)
	vec2 := simd.LoadUint32x16Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x16())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Uint8x64Int8x64Mask32x16Uint32x16(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, v3 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	vec3 := simd.LoadInt32x16Slice(v3)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())
	case "UnsignedSignedQuadDotProdAccumulateMasked":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulateMasked(vec1, vec2, vec3.AsMask32x16())

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Uint8x64Int8x64Uint32x16(t *testing.T, v0 []uint32, v1 []uint8, v2 []int8, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadUint8x64Slice(v1)
	vec2 := simd.LoadInt8x64Slice(v2)
	switch which {
	case "SaturatedUnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.SaturatedUnsignedSignedQuadDotProdAccumulate(vec1, vec2)
	case "UnsignedSignedQuadDotProdAccumulate":
		gotv = vec0.UnsignedSignedQuadDotProdAccumulate(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16Unary(t *testing.T, v0 []uint32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint32x16UnaryMasked(t *testing.T, v0 []uint32, v1 []int32, want []uint32, which string) {
	t.Helper()
	var gotv simd.Uint32x16
	got := make([]uint32, len(want))
	vec0 := simd.LoadUint32x16Slice(v0)
	vec1 := simd.LoadInt32x16Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask32x16())

	default:
		t.Errorf("Unknown method: Uint32x16.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x2())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x2())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x2())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x2())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x2())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x2())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x2())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x2())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x2())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x2())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x2())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x2())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x2())

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x2()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x2()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x2()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x2()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x2()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x2()

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x2
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	vec2 := simd.LoadInt64x2Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x2()).AsInt64x2()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x2()).AsInt64x2()

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2Ternary(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	vec2 := simd.LoadUint64x2Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2TernaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, v3 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadUint64x2Slice(v1)
	vec2 := simd.LoadUint64x2Slice(v2)
	vec3 := simd.LoadInt64x2Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x2())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x2())

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x2UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x2
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x2Slice(v0)
	vec1 := simd.LoadInt64x2Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x2())

	default:
		t.Errorf("Unknown method: Uint64x2.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x4())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x4())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x4())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x4())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x4())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x4())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x4())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x4())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x4())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x4())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x4())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x4())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x4())

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x4()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x4()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x4()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x4()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x4()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x4()

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x4
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	vec2 := simd.LoadInt64x4Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x4()).AsInt64x4()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x4()).AsInt64x4()

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4Ternary(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	vec2 := simd.LoadUint64x4Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4TernaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, v3 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadUint64x4Slice(v1)
	vec2 := simd.LoadUint64x4Slice(v2)
	vec3 := simd.LoadInt64x4Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x4())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x4())

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x4UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x4
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x4Slice(v0)
	vec1 := simd.LoadInt64x4Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x4())

	default:
		t.Errorf("Unknown method: Uint64x4.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8Binary(t *testing.T, v0 []uint64, v1 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	switch which {
	case "Add":
		gotv = vec0.Add(vec1)
	case "And":
		gotv = vec0.And(vec1)
	case "AndNot":
		gotv = vec0.AndNot(vec1)
	case "Max":
		gotv = vec0.Max(vec1)
	case "Min":
		gotv = vec0.Min(vec1)
	case "MulEvenWiden":
		gotv = vec0.MulEvenWiden(vec1)
	case "Or":
		gotv = vec0.Or(vec1)
	case "RotateLeft":
		gotv = vec0.RotateLeft(vec1)
	case "RotateRight":
		gotv = vec0.RotateRight(vec1)
	case "ShiftLeft":
		gotv = vec0.ShiftLeft(vec1)
	case "ShiftRight":
		gotv = vec0.ShiftRight(vec1)
	case "Sub":
		gotv = vec0.Sub(vec1)
	case "Xor":
		gotv = vec0.Xor(vec1)

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8BinaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "AddMasked":
		gotv = vec0.AddMasked(vec1, vec2.AsMask64x8())
	case "AndMasked":
		gotv = vec0.AndMasked(vec1, vec2.AsMask64x8())
	case "AndNotMasked":
		gotv = vec0.AndNotMasked(vec1, vec2.AsMask64x8())
	case "MaxMasked":
		gotv = vec0.MaxMasked(vec1, vec2.AsMask64x8())
	case "MinMasked":
		gotv = vec0.MinMasked(vec1, vec2.AsMask64x8())
	case "MulEvenWidenMasked":
		gotv = vec0.MulEvenWidenMasked(vec1, vec2.AsMask64x8())
	case "OrMasked":
		gotv = vec0.OrMasked(vec1, vec2.AsMask64x8())
	case "RotateLeftMasked":
		gotv = vec0.RotateLeftMasked(vec1, vec2.AsMask64x8())
	case "RotateRightMasked":
		gotv = vec0.RotateRightMasked(vec1, vec2.AsMask64x8())
	case "ShiftLeftMasked":
		gotv = vec0.ShiftLeftMasked(vec1, vec2.AsMask64x8())
	case "ShiftRightMasked":
		gotv = vec0.ShiftRightMasked(vec1, vec2.AsMask64x8())
	case "SubMasked":
		gotv = vec0.SubMasked(vec1, vec2.AsMask64x8())
	case "XorMasked":
		gotv = vec0.XorMasked(vec1, vec2.AsMask64x8())

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8Compare(t *testing.T, v0 []uint64, v1 []uint64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	switch which {
	case "Equal":
		gotv = vec0.Equal(vec1).AsInt64x8()
	case "Greater":
		gotv = vec0.Greater(vec1).AsInt64x8()
	case "GreaterEqual":
		gotv = vec0.GreaterEqual(vec1).AsInt64x8()
	case "Less":
		gotv = vec0.Less(vec1).AsInt64x8()
	case "LessEqual":
		gotv = vec0.LessEqual(vec1).AsInt64x8()
	case "NotEqual":
		gotv = vec0.NotEqual(vec1).AsInt64x8()

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8MaskedCompare(t *testing.T, v0 []uint64, v1 []uint64, v2 []int64, want []int64, which string) {
	t.Helper()
	var gotv simd.Int64x8
	got := make([]int64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	vec2 := simd.LoadInt64x8Slice(v2)
	switch which {
	case "EqualMasked":
		gotv = vec0.EqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterEqualMasked":
		gotv = vec0.GreaterEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "GreaterMasked":
		gotv = vec0.GreaterMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessEqualMasked":
		gotv = vec0.LessEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "LessMasked":
		gotv = vec0.LessMasked(vec1, vec2.AsMask64x8()).AsInt64x8()
	case "NotEqualMasked":
		gotv = vec0.NotEqualMasked(vec1, vec2.AsMask64x8()).AsInt64x8()

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8Ternary(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	vec2 := simd.LoadUint64x8Slice(v2)
	switch which {
	case "ShiftLeftAndFillUpperFrom":
		gotv = vec0.ShiftLeftAndFillUpperFrom(vec1, vec2)
	case "ShiftRightAndFillUpperFrom":
		gotv = vec0.ShiftRightAndFillUpperFrom(vec1, vec2)

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8TernaryMasked(t *testing.T, v0 []uint64, v1 []uint64, v2 []uint64, v3 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadUint64x8Slice(v1)
	vec2 := simd.LoadUint64x8Slice(v2)
	vec3 := simd.LoadInt64x8Slice(v3)
	switch which {
	case "ShiftLeftAndFillUpperFromMasked":
		gotv = vec0.ShiftLeftAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x8())
	case "ShiftRightAndFillUpperFromMasked":
		gotv = vec0.ShiftRightAndFillUpperFromMasked(vec1, vec2, vec3.AsMask64x8())

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8Unary(t *testing.T, v0 []uint64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	switch which {
	case "PopCount":
		gotv = vec0.PopCount()

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

func testUint64x8UnaryMasked(t *testing.T, v0 []uint64, v1 []int64, want []uint64, which string) {
	t.Helper()
	var gotv simd.Uint64x8
	got := make([]uint64, len(want))
	vec0 := simd.LoadUint64x8Slice(v0)
	vec1 := simd.LoadInt64x8Slice(v1)
	switch which {
	case "PopCountMasked":
		gotv = vec0.PopCountMasked(vec1.AsMask64x8())

	default:
		t.Errorf("Unknown method: Uint64x8.%s", which)
	}
	gotv.StoreSlice(got)
	for i := range len(want) {
		if got[i] != want[i] {
			t.Errorf("Result at %d incorrect: want %v, got %v", i, want[i], got[i])
		}
	}
}

/* The operations below cannot be tested via wrappers, please test them directly */

// CeilWithPrecision
// CeilWithPrecisionMasked
// DiffWithCeilWithPrecision
// DiffWithCeilWithPrecisionMasked
// DiffWithFloorWithPrecision
// DiffWithFloorWithPrecisionMasked
// DiffWithRoundWithPrecision
// DiffWithRoundWithPrecisionMasked
// DiffWithTruncWithPrecision
// DiffWithTruncWithPrecisionMasked
// FloorWithPrecision
// FloorWithPrecisionMasked
// GaloisFieldAffineTransform
// GaloisFieldAffineTransformInverse
// GaloisFieldAffineTransformInverseMasked
// GaloisFieldAffineTransformMasked
// Get128
// GetElem
// RotateAllLeft
// RotateAllLeftMasked
// RotateAllRight
// RotateAllRightMasked
// RoundWithPrecision
// RoundWithPrecisionMasked
// Set128
// SetElem
// ShiftAllLeft
// ShiftAllLeftAndFillUpperFrom
// ShiftAllLeftAndFillUpperFromMasked
// ShiftAllLeftMasked
// ShiftAllRight
// ShiftAllRightAndFillUpperFrom
// ShiftAllRightAndFillUpperFromMasked
// ShiftAllRightMasked
// TruncWithPrecision
// TruncWithPrecisionMasked
