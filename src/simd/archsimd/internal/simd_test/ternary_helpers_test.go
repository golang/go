// Code generated by 'go run genfiles.go'; DO NOT EDIT.

//go:build goexperiment.simd

// This file contains functions testing ternary simd methods.
// Each function in this file is specialized for a
// particular simd type <BaseType><Width>x<Count>.

package simd_test

import (
	"simd/archsimd"
	"testing"
)

// testInt8x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt8x16Ternary(t *testing.T, f func(_, _, _ archsimd.Int8x16) archsimd.Int8x16, want func(_, _, _ []int8) []int8) {
	n := 16
	t.Helper()
	forSliceTriple(t, int8s, n, func(x, y, z []int8) bool {
		t.Helper()
		a := archsimd.LoadInt8x16Slice(x)
		b := archsimd.LoadInt8x16Slice(y)
		c := archsimd.LoadInt8x16Slice(z)
		g := make([]int8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt16x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt16x8Ternary(t *testing.T, f func(_, _, _ archsimd.Int16x8) archsimd.Int16x8, want func(_, _, _ []int16) []int16) {
	n := 8
	t.Helper()
	forSliceTriple(t, int16s, n, func(x, y, z []int16) bool {
		t.Helper()
		a := archsimd.LoadInt16x8Slice(x)
		b := archsimd.LoadInt16x8Slice(y)
		c := archsimd.LoadInt16x8Slice(z)
		g := make([]int16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt32x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt32x4Ternary(t *testing.T, f func(_, _, _ archsimd.Int32x4) archsimd.Int32x4, want func(_, _, _ []int32) []int32) {
	n := 4
	t.Helper()
	forSliceTriple(t, int32s, n, func(x, y, z []int32) bool {
		t.Helper()
		a := archsimd.LoadInt32x4Slice(x)
		b := archsimd.LoadInt32x4Slice(y)
		c := archsimd.LoadInt32x4Slice(z)
		g := make([]int32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt64x2Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt64x2Ternary(t *testing.T, f func(_, _, _ archsimd.Int64x2) archsimd.Int64x2, want func(_, _, _ []int64) []int64) {
	n := 2
	t.Helper()
	forSliceTriple(t, int64s, n, func(x, y, z []int64) bool {
		t.Helper()
		a := archsimd.LoadInt64x2Slice(x)
		b := archsimd.LoadInt64x2Slice(y)
		c := archsimd.LoadInt64x2Slice(z)
		g := make([]int64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint8x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint8x16Ternary(t *testing.T, f func(_, _, _ archsimd.Uint8x16) archsimd.Uint8x16, want func(_, _, _ []uint8) []uint8) {
	n := 16
	t.Helper()
	forSliceTriple(t, uint8s, n, func(x, y, z []uint8) bool {
		t.Helper()
		a := archsimd.LoadUint8x16Slice(x)
		b := archsimd.LoadUint8x16Slice(y)
		c := archsimd.LoadUint8x16Slice(z)
		g := make([]uint8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint16x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint16x8Ternary(t *testing.T, f func(_, _, _ archsimd.Uint16x8) archsimd.Uint16x8, want func(_, _, _ []uint16) []uint16) {
	n := 8
	t.Helper()
	forSliceTriple(t, uint16s, n, func(x, y, z []uint16) bool {
		t.Helper()
		a := archsimd.LoadUint16x8Slice(x)
		b := archsimd.LoadUint16x8Slice(y)
		c := archsimd.LoadUint16x8Slice(z)
		g := make([]uint16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint32x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint32x4Ternary(t *testing.T, f func(_, _, _ archsimd.Uint32x4) archsimd.Uint32x4, want func(_, _, _ []uint32) []uint32) {
	n := 4
	t.Helper()
	forSliceTriple(t, uint32s, n, func(x, y, z []uint32) bool {
		t.Helper()
		a := archsimd.LoadUint32x4Slice(x)
		b := archsimd.LoadUint32x4Slice(y)
		c := archsimd.LoadUint32x4Slice(z)
		g := make([]uint32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint64x2Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint64x2Ternary(t *testing.T, f func(_, _, _ archsimd.Uint64x2) archsimd.Uint64x2, want func(_, _, _ []uint64) []uint64) {
	n := 2
	t.Helper()
	forSliceTriple(t, uint64s, n, func(x, y, z []uint64) bool {
		t.Helper()
		a := archsimd.LoadUint64x2Slice(x)
		b := archsimd.LoadUint64x2Slice(y)
		c := archsimd.LoadUint64x2Slice(z)
		g := make([]uint64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat32x4Ternary(t *testing.T, f func(_, _, _ archsimd.Float32x4) archsimd.Float32x4, want func(_, _, _ []float32) []float32) {
	n := 4
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x4Slice(x)
		b := archsimd.LoadFloat32x4Slice(y)
		c := archsimd.LoadFloat32x4Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat64x2Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat64x2Ternary(t *testing.T, f func(_, _, _ archsimd.Float64x2) archsimd.Float64x2, want func(_, _, _ []float64) []float64) {
	n := 2
	t.Helper()
	forSliceTriple(t, float64s, n, func(x, y, z []float64) bool {
		t.Helper()
		a := archsimd.LoadFloat64x2Slice(x)
		b := archsimd.LoadFloat64x2Slice(y)
		c := archsimd.LoadFloat64x2Slice(z)
		g := make([]float64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt8x32Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt8x32Ternary(t *testing.T, f func(_, _, _ archsimd.Int8x32) archsimd.Int8x32, want func(_, _, _ []int8) []int8) {
	n := 32
	t.Helper()
	forSliceTriple(t, int8s, n, func(x, y, z []int8) bool {
		t.Helper()
		a := archsimd.LoadInt8x32Slice(x)
		b := archsimd.LoadInt8x32Slice(y)
		c := archsimd.LoadInt8x32Slice(z)
		g := make([]int8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt16x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt16x16Ternary(t *testing.T, f func(_, _, _ archsimd.Int16x16) archsimd.Int16x16, want func(_, _, _ []int16) []int16) {
	n := 16
	t.Helper()
	forSliceTriple(t, int16s, n, func(x, y, z []int16) bool {
		t.Helper()
		a := archsimd.LoadInt16x16Slice(x)
		b := archsimd.LoadInt16x16Slice(y)
		c := archsimd.LoadInt16x16Slice(z)
		g := make([]int16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt32x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt32x8Ternary(t *testing.T, f func(_, _, _ archsimd.Int32x8) archsimd.Int32x8, want func(_, _, _ []int32) []int32) {
	n := 8
	t.Helper()
	forSliceTriple(t, int32s, n, func(x, y, z []int32) bool {
		t.Helper()
		a := archsimd.LoadInt32x8Slice(x)
		b := archsimd.LoadInt32x8Slice(y)
		c := archsimd.LoadInt32x8Slice(z)
		g := make([]int32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt64x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt64x4Ternary(t *testing.T, f func(_, _, _ archsimd.Int64x4) archsimd.Int64x4, want func(_, _, _ []int64) []int64) {
	n := 4
	t.Helper()
	forSliceTriple(t, int64s, n, func(x, y, z []int64) bool {
		t.Helper()
		a := archsimd.LoadInt64x4Slice(x)
		b := archsimd.LoadInt64x4Slice(y)
		c := archsimd.LoadInt64x4Slice(z)
		g := make([]int64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint8x32Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint8x32Ternary(t *testing.T, f func(_, _, _ archsimd.Uint8x32) archsimd.Uint8x32, want func(_, _, _ []uint8) []uint8) {
	n := 32
	t.Helper()
	forSliceTriple(t, uint8s, n, func(x, y, z []uint8) bool {
		t.Helper()
		a := archsimd.LoadUint8x32Slice(x)
		b := archsimd.LoadUint8x32Slice(y)
		c := archsimd.LoadUint8x32Slice(z)
		g := make([]uint8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint16x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint16x16Ternary(t *testing.T, f func(_, _, _ archsimd.Uint16x16) archsimd.Uint16x16, want func(_, _, _ []uint16) []uint16) {
	n := 16
	t.Helper()
	forSliceTriple(t, uint16s, n, func(x, y, z []uint16) bool {
		t.Helper()
		a := archsimd.LoadUint16x16Slice(x)
		b := archsimd.LoadUint16x16Slice(y)
		c := archsimd.LoadUint16x16Slice(z)
		g := make([]uint16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint32x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint32x8Ternary(t *testing.T, f func(_, _, _ archsimd.Uint32x8) archsimd.Uint32x8, want func(_, _, _ []uint32) []uint32) {
	n := 8
	t.Helper()
	forSliceTriple(t, uint32s, n, func(x, y, z []uint32) bool {
		t.Helper()
		a := archsimd.LoadUint32x8Slice(x)
		b := archsimd.LoadUint32x8Slice(y)
		c := archsimd.LoadUint32x8Slice(z)
		g := make([]uint32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint64x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint64x4Ternary(t *testing.T, f func(_, _, _ archsimd.Uint64x4) archsimd.Uint64x4, want func(_, _, _ []uint64) []uint64) {
	n := 4
	t.Helper()
	forSliceTriple(t, uint64s, n, func(x, y, z []uint64) bool {
		t.Helper()
		a := archsimd.LoadUint64x4Slice(x)
		b := archsimd.LoadUint64x4Slice(y)
		c := archsimd.LoadUint64x4Slice(z)
		g := make([]uint64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat32x8Ternary(t *testing.T, f func(_, _, _ archsimd.Float32x8) archsimd.Float32x8, want func(_, _, _ []float32) []float32) {
	n := 8
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x8Slice(x)
		b := archsimd.LoadFloat32x8Slice(y)
		c := archsimd.LoadFloat32x8Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat64x4Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat64x4Ternary(t *testing.T, f func(_, _, _ archsimd.Float64x4) archsimd.Float64x4, want func(_, _, _ []float64) []float64) {
	n := 4
	t.Helper()
	forSliceTriple(t, float64s, n, func(x, y, z []float64) bool {
		t.Helper()
		a := archsimd.LoadFloat64x4Slice(x)
		b := archsimd.LoadFloat64x4Slice(y)
		c := archsimd.LoadFloat64x4Slice(z)
		g := make([]float64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt8x64Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt8x64Ternary(t *testing.T, f func(_, _, _ archsimd.Int8x64) archsimd.Int8x64, want func(_, _, _ []int8) []int8) {
	n := 64
	t.Helper()
	forSliceTriple(t, int8s, n, func(x, y, z []int8) bool {
		t.Helper()
		a := archsimd.LoadInt8x64Slice(x)
		b := archsimd.LoadInt8x64Slice(y)
		c := archsimd.LoadInt8x64Slice(z)
		g := make([]int8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt16x32Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt16x32Ternary(t *testing.T, f func(_, _, _ archsimd.Int16x32) archsimd.Int16x32, want func(_, _, _ []int16) []int16) {
	n := 32
	t.Helper()
	forSliceTriple(t, int16s, n, func(x, y, z []int16) bool {
		t.Helper()
		a := archsimd.LoadInt16x32Slice(x)
		b := archsimd.LoadInt16x32Slice(y)
		c := archsimd.LoadInt16x32Slice(z)
		g := make([]int16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt32x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt32x16Ternary(t *testing.T, f func(_, _, _ archsimd.Int32x16) archsimd.Int32x16, want func(_, _, _ []int32) []int32) {
	n := 16
	t.Helper()
	forSliceTriple(t, int32s, n, func(x, y, z []int32) bool {
		t.Helper()
		a := archsimd.LoadInt32x16Slice(x)
		b := archsimd.LoadInt32x16Slice(y)
		c := archsimd.LoadInt32x16Slice(z)
		g := make([]int32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testInt64x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testInt64x8Ternary(t *testing.T, f func(_, _, _ archsimd.Int64x8) archsimd.Int64x8, want func(_, _, _ []int64) []int64) {
	n := 8
	t.Helper()
	forSliceTriple(t, int64s, n, func(x, y, z []int64) bool {
		t.Helper()
		a := archsimd.LoadInt64x8Slice(x)
		b := archsimd.LoadInt64x8Slice(y)
		c := archsimd.LoadInt64x8Slice(z)
		g := make([]int64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint8x64Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint8x64Ternary(t *testing.T, f func(_, _, _ archsimd.Uint8x64) archsimd.Uint8x64, want func(_, _, _ []uint8) []uint8) {
	n := 64
	t.Helper()
	forSliceTriple(t, uint8s, n, func(x, y, z []uint8) bool {
		t.Helper()
		a := archsimd.LoadUint8x64Slice(x)
		b := archsimd.LoadUint8x64Slice(y)
		c := archsimd.LoadUint8x64Slice(z)
		g := make([]uint8, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint16x32Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint16x32Ternary(t *testing.T, f func(_, _, _ archsimd.Uint16x32) archsimd.Uint16x32, want func(_, _, _ []uint16) []uint16) {
	n := 32
	t.Helper()
	forSliceTriple(t, uint16s, n, func(x, y, z []uint16) bool {
		t.Helper()
		a := archsimd.LoadUint16x32Slice(x)
		b := archsimd.LoadUint16x32Slice(y)
		c := archsimd.LoadUint16x32Slice(z)
		g := make([]uint16, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint32x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint32x16Ternary(t *testing.T, f func(_, _, _ archsimd.Uint32x16) archsimd.Uint32x16, want func(_, _, _ []uint32) []uint32) {
	n := 16
	t.Helper()
	forSliceTriple(t, uint32s, n, func(x, y, z []uint32) bool {
		t.Helper()
		a := archsimd.LoadUint32x16Slice(x)
		b := archsimd.LoadUint32x16Slice(y)
		c := archsimd.LoadUint32x16Slice(z)
		g := make([]uint32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testUint64x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testUint64x8Ternary(t *testing.T, f func(_, _, _ archsimd.Uint64x8) archsimd.Uint64x8, want func(_, _, _ []uint64) []uint64) {
	n := 8
	t.Helper()
	forSliceTriple(t, uint64s, n, func(x, y, z []uint64) bool {
		t.Helper()
		a := archsimd.LoadUint64x8Slice(x)
		b := archsimd.LoadUint64x8Slice(y)
		c := archsimd.LoadUint64x8Slice(z)
		g := make([]uint64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x16Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat32x16Ternary(t *testing.T, f func(_, _, _ archsimd.Float32x16) archsimd.Float32x16, want func(_, _, _ []float32) []float32) {
	n := 16
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x16Slice(x)
		b := archsimd.LoadFloat32x16Slice(y)
		c := archsimd.LoadFloat32x16Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat64x8Ternary tests the simd ternary method f against the expected behavior generated by want
func testFloat64x8Ternary(t *testing.T, f func(_, _, _ archsimd.Float64x8) archsimd.Float64x8, want func(_, _, _ []float64) []float64) {
	n := 8
	t.Helper()
	forSliceTriple(t, float64s, n, func(x, y, z []float64) bool {
		t.Helper()
		a := archsimd.LoadFloat64x8Slice(x)
		b := archsimd.LoadFloat64x8Slice(y)
		c := archsimd.LoadFloat64x8Slice(z)
		g := make([]float64, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, 0.0, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x4TernaryFlaky tests the simd ternary method f against the expected behavior generated by want,
// but using a flakiness parameter because we haven't exactly figured out how simd floating point works
func testFloat32x4TernaryFlaky(t *testing.T, f func(x, y, z archsimd.Float32x4) archsimd.Float32x4, want func(x, y, z []float32) []float32, flakiness float64) {
	n := 4
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x4Slice(x)
		b := archsimd.LoadFloat32x4Slice(y)
		c := archsimd.LoadFloat32x4Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, flakiness, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x8TernaryFlaky tests the simd ternary method f against the expected behavior generated by want,
// but using a flakiness parameter because we haven't exactly figured out how simd floating point works
func testFloat32x8TernaryFlaky(t *testing.T, f func(x, y, z archsimd.Float32x8) archsimd.Float32x8, want func(x, y, z []float32) []float32, flakiness float64) {
	n := 8
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x8Slice(x)
		b := archsimd.LoadFloat32x8Slice(y)
		c := archsimd.LoadFloat32x8Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, flakiness, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}

// testFloat32x16TernaryFlaky tests the simd ternary method f against the expected behavior generated by want,
// but using a flakiness parameter because we haven't exactly figured out how simd floating point works
func testFloat32x16TernaryFlaky(t *testing.T, f func(x, y, z archsimd.Float32x16) archsimd.Float32x16, want func(x, y, z []float32) []float32, flakiness float64) {
	n := 16
	t.Helper()
	forSliceTriple(t, float32s, n, func(x, y, z []float32) bool {
		t.Helper()
		a := archsimd.LoadFloat32x16Slice(x)
		b := archsimd.LoadFloat32x16Slice(y)
		c := archsimd.LoadFloat32x16Slice(z)
		g := make([]float32, n)
		f(a, b, c).StoreSlice(g)
		w := want(x, y, z)
		return checkSlicesLogInput(t, g, w, flakiness, func() { t.Helper(); t.Logf("x=%v", x); t.Logf("y=%v", y); t.Logf("z=%v", z) })
	})
}
