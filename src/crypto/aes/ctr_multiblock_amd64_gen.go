// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

// Generate Go assembly for XORing CTR output to n blocks at once with one key.

package main

import (
	"fmt"
	"os"
	"text/template"
)

var tmplAmd64Str = `
// Code generated by ctr_multiblock_amd64_gen.go. DO NOT EDIT.

#include "textflag.h"

// See https://golang.org/src/crypto/aes/gcm_amd64.s
#define NR CX
#define XK AX
#define DST DX
#define SRC R10
#define IV_PTR BX
#define BLOCK_INDEX R11
#define IV_LOW_LE R12
#define IV_HIGH_LE R13
#define BSWAP X15

DATA bswapMask<>+0x00(SB)/8, $0x08090a0b0c0d0e0f
DATA bswapMask<>+0x08(SB)/8, $0x0001020304050607

GLOBL bswapMask<>(SB), (NOPTR+RODATA), $16

{{define "enc"}}
	MOVUPS {{ mul $.AX 16 }}(XK), {{ $.RegKey }}
	{{- range $i := xrange .N }}
		{{ $.Instruction }} {{ $.RegKey }}, X{{ $i }}
	{{- end }}
{{ end }}

{{ range $N := $.Sizes }}
{{ $RegKey := printf "X%d" $N }}
// func ctrBlocks{{ $N }}Asm(nr int, xk *uint32, dst, src, ivRev *byte, blockIndex uint64)
TEXT ·ctrBlocks{{ $N }}Asm(SB),NOSPLIT,$0
	MOVQ nr+0(FP), NR
	MOVQ xk+8(FP), XK
	MOVUPS 0(XK), {{ $RegKey }}
	MOVQ dst+16(FP), DST
	MOVQ src+24(FP), SRC
	MOVQ ivRev+32(FP), IV_PTR
	MOVQ 0(IV_PTR), IV_LOW_LE
	MOVQ 8(IV_PTR), IV_HIGH_LE
	MOVQ blockIndex+40(FP), BLOCK_INDEX

	MOVOU bswapMask<>(SB), BSWAP

	{{/* Prepare plain from IV and blockIndex. */}}

	{{/* Add blockIndex. */}}
	ADDQ BLOCK_INDEX, IV_LOW_LE
	ADCQ $0, IV_HIGH_LE

	{{/* Copy to plaintext registers. */}}
	{{ range $i := xrange $N }}
		{{/* https://stackoverflow.com/a/2231893 */}}
		MOVQ IV_LOW_LE, X{{ $i }}
		PINSRQ $1, IV_HIGH_LE, X{{ $i }}
		PSHUFB BSWAP, X{{ $i }}
		{{- if ne (add $i 1) $N }}
			ADDQ $1, IV_LOW_LE
			ADCQ $0, IV_HIGH_LE
		{{ end }}
	{{ end }}

	{{/* Initial key add. */}}
	{{ range $i := xrange $N -}}
		PXOR {{ $RegKey }}, X{{ $i }}
	{{ end }}
	ADDQ $16, XK

	{{/* Num rounds branching. */}}
	SUBQ $12, NR
	JE Lenc192
	JB Lenc128

	{{/* 2 extra rounds for 256-bit keys. */}}
	Lenc256:
	{{- template "enc" (enc_args "AESENC" 0 $N) }}
	{{ template "enc" (enc_args "AESENC" 1 $N) }}
	ADDQ $32, XK

	{{/* 2 extra rounds for 192-bit keys. */}}
	Lenc192:
	{{- template "enc" (enc_args "AESENC" 0 $N) }}
	{{ template "enc" (enc_args "AESENC" 1 $N) }}
	ADDQ $32, XK

	{{/* 10 rounds for 128-bit (with special handling for final). */}}
	Lenc128:
	{{- range $ax := xrange 9 }}
		{{- template "enc" (enc_args "AESENC" $ax $N) }}
	{{ end }}
	{{ template "enc" (enc_args "AESENCLAST" 9 $N) }}

	{{/*
	XOR results to destination. Use X8-X15 for that.
	It overwrites BSWAP in the end, but it is not needed.
	*/}}
	{{ range $i := xrange $N }}
		{{ $offset := mul $i 16 }}
		{{ $xor_reg := add $i 8 }}
		MOVUPS {{ $offset }}(SRC), X{{ $xor_reg }}
		PXOR X{{ $i }}, X{{ $xor_reg }}
		MOVUPS X{{ $xor_reg }}, {{ $offset }}(DST)
	{{ end }}

	RET
{{ end }}

// func rev16Asm(iv *byte)
TEXT ·rev16Asm(SB),NOSPLIT,$0
	MOVQ iv+0(FP), IV_PTR
	MOVUPS 0(IV_PTR), X0
	MOVOU bswapMask<>(SB), BSWAP
	PSHUFB BSWAP, X0
	MOVUPS X0, 0(IV_PTR)

	RET
`

func main() {
	type Params struct {
		Sizes []int
	}

	params := Params{
		Sizes: []int{1, 2, 4, 8},
	}

	type EncArgs struct {
		AX          int
		N           int
		RegKey      string
		Instruction string
	}

	funcs := template.FuncMap{
		"add": func(a, b int) int {
			return a + b
		},
		"mul": func(a, b int) int {
			return a * b
		},
		"xrange": func(n int) []int {
			result := make([]int, n)
			for i := 0; i < n; i++ {
				result[i] = i
			}
			return result
		},
		"enc_args": func(inst string, ax, n int) EncArgs {
			return EncArgs{
				AX:          ax,
				N:           n,
				RegKey:      fmt.Sprintf("X%d", n),
				Instruction: inst,
			}
		},
	}

	var tmpl = template.Must(template.New("ctr_multiblock_amd64").Funcs(funcs).Parse(tmplAmd64Str))

	if err := tmpl.Execute(os.Stdout, params); err != nil {
		panic(err)
	}
}
