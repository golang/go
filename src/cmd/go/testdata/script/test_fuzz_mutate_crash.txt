# TODO(jayconrod): support shared memory on more platforms.
[!darwin] [!linux] [!windows] skip

# Tests that a crash caused by a mutator-discovered input writes the bad input
# to testdata, and fails+reports correctly. This tests the end-to-end behavior
# of the mutator finding a crash while fuzzing, adding it as a regression test
# to the seed corpus in testdata, and failing the next time the test is run.

[short] skip

# TODO: remove -parallel=1 once the races are fixed.

# Running the seed corpus for all of the targets should pass the first
# time, since nothing in the seed corpus will cause a crash.
go test -parallel=1

# Running the fuzzer should find a crashing input quickly.
! go test -fuzz=FuzzWithBug -fuzztime=5s -parallel=1
stdout 'testdata[/\\]corpus[/\\]FuzzWithBug[/\\]'
stdout 'this input caused a crash!'
go run check_testdata.go FuzzWithBug

# Now, the failing bytes should have been added to the seed corpus for
# the target, and should fail when run without fuzzing.
! go test -parallel=1

# Running the fuzzer should find a crashing input quickly for fuzzing two types.
! go test -run=FuzzWithTwoTypes -fuzz=FuzzWithTwoTypes -fuzztime=5s -parallel=1
stdout 'testdata[/\\]corpus[/\\]FuzzWithTwoTypes[/\\]'
stdout 'these inputs caused a crash!'
go run check_testdata.go FuzzWithTwoTypes

! go test -run=FuzzWithNilPanic -fuzz=FuzzWithNilPanic -fuzztime=5s -parallel=1
stdout 'testdata[/\\]corpus[/\\]FuzzWithNilPanic[/\\]'
stdout 'runtime.Goexit'
go run check_testdata.go FuzzWithNilPanic

! go test -run=FuzzWithBadExit -fuzz=FuzzWithBadExit -fuzztime=5s -parallel=1
stdout 'testdata[/\\]corpus[/\\]FuzzWithBadExit[/\\]'
stdout 'unexpectedly'
go run check_testdata.go FuzzWithBadExit

-- go.mod --
module m

go 1.16
-- fuzz_crash_test.go --
package fuzz_crash

import (
    "os"
	"testing"
)

func FuzzWithBug(f *testing.F) {
	f.Add([]byte("aa"))
	f.Fuzz(func(t *testing.T, b []byte) {
		if string(b) != "aa" {
			panic("this input caused a crash!")
		}
	})
}

func FuzzWithNilPanic(f *testing.F) {
	f.Add([]byte("aa"))
	f.Fuzz(func(t *testing.T, b []byte) {
		if string(b) != "aa" {
			panic(nil)
		}
	})
}

func FuzzWithTwoTypes(f *testing.F) {
	f.Fuzz(func(t *testing.T, a, b []byte) {
		if len(a) > 0 && len(b) > 0 {
			panic("these inputs caused a crash!")
		}
	})
}

func FuzzWithBadExit(f *testing.F) {
	f.Add([]byte("aa"))
	f.Fuzz(func(t *testing.T, b []byte) {
		if string(b) != "aa" {
			os.Exit(1)
		}
	})
}

-- check_testdata.go --
// +build ignore

package main

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func main() {
	target := os.Args[1]
	dir := filepath.Join("testdata/corpus", target)

	files, err := ioutil.ReadDir(dir)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	if len(files) != 1 {
		fmt.Fprintln(os.Stderr, fmt.Errorf("expect only one new mutation to be written to testdata", len(files)))
		os.Exit(1)
	}

	fname := files[0].Name()
	contents, err := ioutil.ReadFile(filepath.Join(dir, fname))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if bytes.Equal(contents, []byte("aa")) {
		fmt.Fprintln(os.Stderr, fmt.Errorf("newly written testdata entry was not mutated"))
		os.Exit(1)
	}
	// The hash of the bytes in the file should match the filename.
	h := []byte(fmt.Sprintf("%x", sha256.Sum256(contents)))
	if !bytes.Equal([]byte(fname), h) {
		fmt.Fprintln(os.Stderr, fmt.Errorf("hash of bytes %q does not match filename %q", h, fname))
		os.Exit(1)
	}
}