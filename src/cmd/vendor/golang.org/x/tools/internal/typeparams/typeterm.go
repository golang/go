// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by copytermlist.go DO NOT EDIT.

package typeparams

import "go/types"

// A term describes elementary type sets:
//
//	 âˆ…:  (*term)(nil)     == âˆ…                      // set of no types (empty set)
//	 ğ“¤:  &term{}          == ğ“¤                      // set of all types (ğ“¤niverse)
//	 T:  &term{false, T}  == {T}                    // set of type T
//	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
type term struct {
	tilde bool // valid if typ != nil
	typ   types.Type
}

func (x *term) String() string {
	switch {
	case x == nil:
		return "âˆ…"
	case x.typ == nil:
		return "ğ“¤"
	case x.tilde:
		return "~" + x.typ.String()
	default:
		return x.typ.String()
	}
}

// equal reports whether x and y represent the same type set.
func (x *term) equal(y *term) bool {
	// easy cases
	switch {
	case x == nil || y == nil:
		return x == y
	case x.typ == nil || y.typ == nil:
		return x.typ == y.typ
	}
	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤

	return x.tilde == y.tilde && types.Identical(x.typ, y.typ)
}

// union returns the union x âˆª y: zero, one, or two non-nil terms.
func (x *term) union(y *term) (_, _ *term) {
	// easy cases
	switch {
	case x == nil && y == nil:
		return nil, nil // âˆ… âˆª âˆ… == âˆ…
	case x == nil:
		return y, nil // âˆ… âˆª y == y
	case y == nil:
		return x, nil // x âˆª âˆ… == x
	case x.typ == nil:
		return x, nil // ğ“¤ âˆª y == ğ“¤
	case y.typ == nil:
		return y, nil // x âˆª ğ“¤ == ğ“¤
	}
	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤

	if x.disjoint(y) {
		return x, y // x âˆª y == (x, y) if x âˆ© y == âˆ…
	}
	// x.typ == y.typ

	// ~t âˆª ~t == ~t
	// ~t âˆª  T == ~t
	//  T âˆª ~t == ~t
	//  T âˆª  T ==  T
	if x.tilde || !y.tilde {
		return x, nil
	}
	return y, nil
}

// intersect returns the intersection x âˆ© y.
func (x *term) intersect(y *term) *term {
	// easy cases
	switch {
	case x == nil || y == nil:
		return nil // âˆ… âˆ© y == âˆ… and âˆ© âˆ… == âˆ…
	case x.typ == nil:
		return y // ğ“¤ âˆ© y == y
	case y.typ == nil:
		return x // x âˆ© ğ“¤ == x
	}
	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤

	if x.disjoint(y) {
		return nil // x âˆ© y == âˆ… if x âˆ© y == âˆ…
	}
	// x.typ == y.typ

	// ~t âˆ© ~t == ~t
	// ~t âˆ©  T ==  T
	//  T âˆ© ~t ==  T
	//  T âˆ©  T ==  T
	if !x.tilde || y.tilde {
		return x
	}
	return y
}

// includes reports whether t âˆˆ x.
func (x *term) includes(t types.Type) bool {
	// easy cases
	switch {
	case x == nil:
		return false // t âˆˆ âˆ… == false
	case x.typ == nil:
		return true // t âˆˆ ğ“¤ == true
	}
	// âˆ… âŠ‚ x âŠ‚ ğ“¤

	u := t
	if x.tilde {
		u = under(u)
	}
	return types.Identical(x.typ, u)
}

// subsetOf reports whether x âŠ† y.
func (x *term) subsetOf(y *term) bool {
	// easy cases
	switch {
	case x == nil:
		return true // âˆ… âŠ† y == true
	case y == nil:
		return false // x âŠ† âˆ… == false since x != âˆ…
	case y.typ == nil:
		return true // x âŠ† ğ“¤ == true
	case x.typ == nil:
		return false // ğ“¤ âŠ† y == false since y != ğ“¤
	}
	// âˆ… âŠ‚ x, y âŠ‚ ğ“¤

	if x.disjoint(y) {
		return false // x âŠ† y == false if x âˆ© y == âˆ…
	}
	// x.typ == y.typ

	// ~t âŠ† ~t == true
	// ~t âŠ† T == false
	//  T âŠ† ~t == true
	//  T âŠ†  T == true
	return !x.tilde || y.tilde
}

// disjoint reports whether x âˆ© y == âˆ….
// x.typ and y.typ must not be nil.
func (x *term) disjoint(y *term) bool {
	if debug && (x.typ == nil || y.typ == nil) {
		panic("invalid argument(s)")
	}
	ux := x.typ
	if y.tilde {
		ux = under(ux)
	}
	uy := y.typ
	if x.tilde {
		uy = under(uy)
	}
	return !types.Identical(ux, uy)
}
