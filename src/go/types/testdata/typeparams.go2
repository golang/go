// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package p

func identity(type T)(x T) T { return x }

func _(type)(x int) int
func _(type T)(T T) T { return T }
func _(type T)(T T) T { var x T /* ERROR T.*is not a type */ ; return x }
func _(type T, T /* ERROR redeclared */ )()

func reverse(type T)(list []T) []T {
        rlist := make([]T, len(list))
        i := len(list)
        for _, x := range list {
                i--
                rlist[i] = x
        }
        return rlist
}

var _ = reverse /* ERROR cannot use generic function reverse */
var _ = reverse(int, float32 /* ERROR got 2 type arguments */ ) ([]int{1, 2, 3})
var _ = reverse(int)([ /* ERROR cannot use */ ]float32{1, 2, 3})
var f = reverse(chan int)
var _ = f(0 /* ERROR cannot convert 0 .* to \[\]chan int */ )

func swap(type A, B)(a A, b B) (B, A) { return b, a }

var _ = swap /* ERROR single value is expected */ (int, float32)(1, 2)
var f32, i = swap(int, float32)(swap(float32, int)(1, 2))
var _ float32 = f32
var _ int = i

func swapswap(type A, B)(a A, b B) (A, B) {
        return swap(B, A)(b, a)
}

// type F(type A, B) func(A, B) (B, A)

func min(type T)(x, y T) T {
        //if x < y {
        //        return x
        //}
        return y
}

func new(type T)() *T {
        var x T
        return &x
}

var _ = new /* ERROR cannot use generic function new */
var _ *int = new(int)()

func _(type T)(map[T /* ERROR invalid map key type */]int) // w/o contract we don't know if T is comparable

func f1(type T1)(struct{T1}) int
var _ = f1(int)(struct{T1}{})
type T1 = int

func f2(type t1)(struct{t1; x float32}) int
var _ = f2(t1)(struct{t1; x float32}{})
type t1 = int


func f3(type A, B, C)(A, struct{x B}, func(A, struct{x B}, *C)) int

var _ = f3(int, rune, bool)(1, struct{x rune}{}, nil)

// type inference checks

var _ = new() /* ERROR cannot infer T */

func f4(type A, B, C)(A, B) C

var _ = f4(1, 2) /* ERROR cannot infer C */
var _ = f4(int, float32, complex128)(1, 2)

func f5(type A, B, C)(A, []*B, struct{f []C}) int

var _ = f5(int, float32, complex128)(0, nil, struct{f []complex128}{})
var _ = f5(0, nil, struct{f []complex128}{}) // ERROR cannot infer
var _ = f5(0, []*float32{new(float32)()}, struct{f []complex128}{})

func f6(type A)(A, []A) int

var _ = f6(0, nil)

func f6nil(type A)(A) int

var _ = f6nil(nil) // ERROR cannot infer

// type inference with variadic functions

func f7(type T)(...T) T

var _ int = f7() /* ERROR cannot infer T */
var _ int = f7(1)
var _ int = f7(1, 2)
var _ int = f7([]int{}...)
var _ int = f7 /* ERROR cannot use */ ([]float64{}...)
var _ float64 = f7([]float64{}...)
var _ = f7(float64)(1, 2.3)
var _ = f7(float64(1), 2.3)
var _ = f7(1, 2.3 /* ERROR does not match */ )
var _ = f7(1.2, 3 /* ERROR does not match */ )

func f8(type A, B)(A, B, ...B) int

var _ = f8(1) /* ERROR not enough arguments */
var _ = f8(1, 2.3)
var _ = f8(1, 2.3, 3.4, 4.5)
var _ = f8(1, 2.3, 3.4, 4 /* ERROR does not match */ )
var _ = f8(int, float64)(1, 2.3, 3.4, 4)

var _ = f8(int, float64)(0, 0, nil...) // test case for #18268

// init functions and methods cannot have type parameters

func init() {}
func init(/* ERROR func init must have no type parameters */ type)() {}
func init(/* ERROR func init must have no type parameters */ type P)() {}

type T struct {}

func (T) m1() {}
func (T) m2( /* ERROR method must have no type parameters */ type)() {}
func (T) m3( /* ERROR method must have no type parameters */ type P)() {}

// type inference across parameterized types

type S1(type P) struct { f P }

func f9(type P)(x S1(P))

func _() {
        f9(int)(S1(int){42})
	f9(S1(int){42})
}

type S2(type A, B, C) struct{}

func f10(type X, Y, Z)(a S2(X, int, Z), b S2(X, Y, bool))

func _(type P)() {
        f10(int, float32, string)(S2(int, int, string){}, S2(int, float32, bool){})
        f10(S2(int, int, string){}, S2(int, float32, bool){})
        f10(S2(P, int, P){}, S2(P, float32, bool){})
}

// method expressions

func (_ S1(P)) m()

func _() {
	m := S1(int).m
	m(struct { f int }{42})
}

func _(type T) (x T) {
        m := S1(T).m
        m(S1(T){x})
}
