// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolution

func f /* =@fdecl */(n /* =@narg */ ast.Node) bool {
		if n /* =@ninit */, ok /* =@ok */ := n /* @narg */ .(*ast.SelectorExpr); ok /* @ok */ {
			sel = n /* @ninit */
	}
}

type c /* =@cdecl */ map[token.Pos]resolvedObj

func (v /* =@vdecl */ c /* @cdecl */) Visit(node /* =@nodearg */ ast.Node) (w /* =@w */ ast.Visitor) {}

const (
	basic /* =@basic */ = iota
	labelOk // =@labelOk
)

type T /* =@T */ int

func _(count /* =@count */ T /* @T */) {
	x /* =@x1 */ := c /* @cdecl */{}
	switch x /* =@x2 */ := x /* @x1 */; x /* =@x3 */ := x /* @x2 */.(type) {
	case c /* @cdecl */:
	default:
	}
loop /* =@loop */:
	for {
		if true {
			break loop /* @loop */
		}
	}
	select {
	case err /* =@err1 */ := <-_:
		return err /* @err1 */
	case err /* =@err2 */ := <-_:
		return err /* @err2 */
	}

	_ = func(p1 /* =@p1 */ int, p2 /* =@p2 */ p1) {
		closed /* =@closed */ := p1 // @p1
		shadowed /* =@shadowed1 */ := p2 // @p2
		_ = func(shadowed /* =@shadowed2 */ p2 /* @p2 */) {
			closed /* @closed */ = 1
			shadowed /* @shadowed2 */ = 2
		}
	}
}

func (r /* =@r */ c /* @cdecl */) m(_ r) c /* @cdecl */ { return r /* @r */ }

var cycle /* =@cycle */ = cycle /* @cycle */ + 1

type chain /* =@chain */ struct {
	next /* =@next */ *chain /* @chain */
}

func recursive /* =@recursive */() {
	recursive /* @recursive */ ()
}
